<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Opulent Voice Radio Interface</title>
	
	<!-- Accessibility and SEO -->
	<meta name="description" content="Amateur Radio Digital Voice and Chat Interface">
	<meta name="theme-color" content="#1a1a2e">
	
	<!-- Skip link for keyboard users -->
	<a href="#main-content" class="skip-link">Skip to main content</a>
	
	<style>
		/* Include all the existing CSS from your original file */
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		:root {
			--primary-color: #1e3c72;
			--secondary-color: #2a5298;
			--accent-color: #42a5f5;
			--success-color: #4caf50;
			--warning-color: #ff9800;
			--error-color: #f44336;
			--text-primary: #ffffff;
			--text-secondary: rgba(255, 255, 255, 0.8);
			--bg-glass: rgba(255, 255, 255, 0.1);
			--bg-glass-hover: rgba(255, 255, 255, 0.15);
			--border-glass: rgba(255, 255, 255, 0.2);
			--shadow-main: 0 15px 35px rgba(0, 0, 0, 0.2);
			--shadow-hover: 0 20px 40px rgba(0, 0, 0, 0.3);
		}

		.skip-link {
			position: absolute;
			top: -40px;
			left: 6px;
			background: var(--accent-color);
			color: white;
			padding: 8px;
			text-decoration: none;
			border-radius: 4px;
			z-index: 1000;
		}

		.skip-link:focus {
			top: 6px;
		}

		.sr-only {
			position: absolute;
			width: 1px;
			height: 1px;
			padding: 0;
			margin: -1px;
			overflow: hidden;
			clip: rect(0, 0, 0, 0);
			white-space: nowrap;
			border: 0;
		}

		body {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 50%, var(--primary-color) 100%);
			min-height: 100vh;
			color: var(--text-primary);
			line-height: 1.6;
		}

		/* Header */
		.main-header {
			background: var(--bg-glass);
			backdrop-filter: blur(20px);
			border-bottom: 1px solid var(--border-glass);
			padding: 1rem 2rem;
			position: sticky;
			top: 0;
			z-index: 100;
		}

		.header-content {
			display: flex;
			justify-content: space-between;
			align-items: center;
			max-width: 1400px;
			margin: 0 auto;
		}

		.app-title {
			font-size: 1.8rem;
			font-weight: 600;
			display: flex;
			align-items: center;
			gap: 0.5rem;
		}

		.app-icon {
			font-size: 2rem;
			filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
		}

		.connection-status {
			display: flex;
			align-items: center;
			gap: 0.5rem;
			padding: 0.5rem 1rem;
			background: var(--bg-glass);
			border-radius: 12px;
			border: 1px solid var(--border-glass);
		}

		.status-indicator {
			width: 12px;
			height: 12px;
			border-radius: 50%;
			animation: pulse 2s infinite;
		}

		.status-indicator.connected {
			background: var(--success-color);
		}

		.status-indicator.disconnected {
			background: var(--error-color);
		}

		.status-indicator.connecting {
			background: var(--warning-color);
		}

		@keyframes pulse {
			0%, 100% { opacity: 1; }
			50% { opacity: 0.5; }
		}

		.header-controls {
			display: flex;
			gap: 1rem;
			align-items: center;
		}

		.tab-navigation {
			display: flex;
			gap: 0.5rem;
		}

		.tab-button {
			padding: 0.5rem 1rem;
			background: transparent;
			border: 2px solid var(--border-glass);
			border-radius: 8px;
			color: var(--text-secondary);
			cursor: pointer;
			transition: all 0.3s ease;
			font-size: 0.9rem;
		}

		.tab-button:hover {
			background: var(--bg-glass-hover);
			color: var(--text-primary);
		}

		.tab-button.active {
			background: var(--accent-color);
			border-color: var(--accent-color);
			color: white;
		}

		/* Main Layout */
		.main-container {
			/* max-width: 1400px; */
			max-width: 100%;
			margin: 0 auto;
			padding: 2rem;
			display: grid;
			grid-template-columns: 1fr 400px;
			gap: 2rem;
			min-height: calc(100vh - 120px);
			/* trying to make message history take up all the height */
			height: calc(100vh - 100px);
		}

		@media (max-width: 1200px) {
			.main-container {
				grid-template-columns: 1fr;
				gap: 1.5rem;
			}
		}

		/* Panel Styles */
		.panel {
			background: var(--bg-glass);
			backdrop-filter: blur(20px);
			border: 1px solid var(--border-glass);
			border-radius: 20px;
			padding: 1.5rem;
			box-shadow: var(--shadow-main);
			transition: all 0.3s ease;
		}

		.panel:hover {
			transform: translateY(-2px);
			box-shadow: var(--shadow-hover);
		}

		.panel-title {
			font-size: 1.4rem;
			font-weight: 600;
			margin-bottom: 1.5rem;
			display: flex;
			align-items: center;
			gap: 0.5rem;
		}

		.panel-icon {
			font-size: 1.6rem;
			filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
		}

		/* Chat Interface */
		.chat-container {
			display: grid;
			grid-template-rows: auto 1fr auto;
			/* height: 600px; */
			/* max-height: 1125; */ /* worked! do not exceed system status height */
			height: calc(100vh - 240px);  /* Full viewport minus header/padding */
			gap: 1rem;
		}

		.chat-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding-bottom: 1rem;
			border-bottom: 1px solid var(--border-glass);
		}

		.station-info {
			font-size: 1.1rem;
			font-weight: 500;
		}

		.ptt-button {
			padding: 0.8rem 1.5rem;
			background: linear-gradient(45deg, var(--success-color), #43a047);
			border: none;
			border-radius: 12px;
			color: white;
			font-size: 1.2rem;
			font-weight: 600;
			cursor: pointer;
			transition: all 0.3s ease;
			display: flex;
			align-items: center;
			gap: 0.5rem;
			min-width: 120px;
			justify-content: center;
		}

		.ptt-button:hover {
			transform: translateY(-2px);
			box-shadow: 0 10px 25px rgba(76, 175, 80, 0.4);
		}

		.ptt-button.active {
			background: linear-gradient(45deg, var(--error-color), #d32f2f);
			animation: ptt-active 0.5s ease infinite alternate;
		}

		.ptt-button:disabled {
			opacity: 0.5;
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
		}

		@keyframes ptt-active {
			from { box-shadow: 0 0 20px rgba(244, 67, 54, 0.6); }
			to { box-shadow: 0 0 30px rgba(244, 67, 54, 0.8); }
		}

		.message-history {
			background: rgba(0, 0, 0, 0.1);
			border-radius: 12px;
			padding: 1rem;
			overflow-y: auto;
			display: flex;
			flex-direction: column;
			gap: 0.5rem;
			/* max-height: 400px; but 1000px really worked well */
			min-height: 200px;
			height: 100%;
		}

		.message {
			padding: 0.8rem 1rem;
			border-radius: 12px;
			max-width: 80%;
			word-wrap: break-word;
			animation: messageAppear 0.3s ease;
		}

		@keyframes messageAppear {
			from { opacity: 0; transform: translateY(10px); }
			to { opacity: 1; transform: translateY(0); }
		}

		.message.outgoing {
			background: linear-gradient(45deg, var(--accent-color), #1976d2);
			align-self: flex-end;
			margin-left: auto;
		}

		.message.incoming {
			background: var(--bg-glass);
			border: 1px solid var(--border-glass);
			align-self: flex-start;
		}

		.message.system {
			background: rgba(255, 193, 7, 0.2);
			border: 1px solid rgba(255, 193, 7, 0.5);
			align-self: center;
			text-align: center;
			font-style: italic;
			max-width: 90%;
		}

		.message-meta {
			font-size: 0.8rem;
			opacity: 0.7;
			margin-top: 0.3rem;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.message-input-form {
			/* border: 1px solid red !important; */
			display: flex;
			gap: 0.5rem;
			/* align-items: flex-end; */
			align-items: center;
		}

		.input-container {
			flex: 1;
			position: relative;
		}

		.message-input {
			width: 100%;
			padding: 0.8rem 1rem;
			border: 2px solid var(--border-glass);
			border-radius: 12px;
			background: var(--bg-glass);
			color: var(--text-primary);
			font-size: 1rem;
			resize: none;
			min-height: 45px;
			max-height: 100px;
		}

		.message-input:focus {
			outline: none;
			border-color: var(--accent-color);
			box-shadow: 0 0 20px rgba(66, 165, 245, 0.3);
		}

		.message-input::placeholder {
			color: var(--text-secondary);
		}

		.message-input:disabled {
			opacity: 0.5;
			cursor: not-allowed;
		}

		.send-button {
			padding: 0.8rem 1rem;
			background: linear-gradient(45deg, var(--success-color), #43a047) !important;
			border: none;
			border-radius: 12px;
			color: white;
			cursor: pointer;
			transition: all 0.3s ease;
			min-width: 60px;		
			height: 45px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 1.2rem;
			font-weight: 600;
		}

		.send-button:hover {
			transform: translateY(-2px);
			box-shadow: 0 10px 25px rgba(66, 165, 245, 0.4);
		}

		.send-button:disabled {
			opacity: 0.5;
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
		}

		/* Configuration Tabs */
		.config-tabs {
			display: none;
		}

		.config-tabs.active {
			display: block;
		}

		.config-grid {
			display: grid;
			gap: 1.5rem;
		}

		.config-section {
			background: rgba(255, 255, 255, 0.05);
			border-radius: 12px;
			padding: 1.5rem;
			border: 1px solid var(--border-glass);
		}

		.section-header {
			font-size: 1.2rem;
			font-weight: 600;
			margin-bottom: 1rem;
			display: flex;
			align-items: center;
			gap: 0.5rem;
		}

		.form-group {
			margin-bottom: 1rem;
		}

		.form-group label {
			display: block;
			margin-bottom: 0.5rem;
			font-weight: 500;
			color: var(--text-secondary);
		}

		.form-group input,
		.form-group select {
			width: 100%;
			padding: 0.8rem 1rem;
			border: 2px solid var(--border-glass);
			border-radius: 8px;
			background: var(--bg-glass);
			color: var(--text-primary);
			font-size: 1rem;
			transition: all 0.3s ease;
		}

		.form-group input:focus,
		.form-group select:focus {
			outline: none;
			border-color: var(--accent-color);
			box-shadow: 0 0 15px rgba(66, 165, 245, 0.3);
		}

		.form-group input::placeholder {
			color: var(--text-secondary);
		}

		/* Buttons */
		.btn {
			padding: 0.8rem 1.5rem;
			border: none;
			border-radius: 12px;
			font-size: 1rem;
			font-weight: 600;
			cursor: pointer;
			transition: all 0.3s ease;
			background: var(--bg-glass);
			color: var(--text-primary);
			border: 2px solid var(--border-glass);
			backdrop-filter: blur(10px);
			display: inline-flex;
			align-items: center;
			gap: 0.5rem;
		}

		.btn:hover {
			transform: translateY(-2px);
			box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
		}

		.btn-primary {
			background: linear-gradient(45deg, var(--accent-color), #1976d2);
			border-color: var(--accent-color);
		}

		.btn-success {
			background: linear-gradient(45deg, var(--success-color), #43a047);
			border-color: var(--success-color);
		}

		.btn:disabled {
			opacity: 0.5;
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
		}

		/* Status Panel */
		.status-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			gap: 1rem;
			margin-bottom: 1.5rem;
		}

		.stat-item {
			background: rgba(255, 255, 255, 0.05);
			padding: 1rem;
			border-radius: 8px;
			text-align: center;
		}

		.stat-label {
			display: block;
			font-size: 0.9rem;
			color: var(--text-secondary);
			margin-bottom: 0.5rem;
		}

		.stat-value {
			font-size: 1.5rem;
			font-weight: 600;
			color: var(--accent-color);
		}

		/* System Log */
		.log-section {
			margin-top: 1.5rem;
		}

		.log-controls {
			display: flex;
			gap: 1rem;
			margin-bottom: 1rem;
			align-items: center;
		}

		.system-log {
			background: rgba(0, 0, 0, 0.2);
			border-radius: 8px;
			padding: 1rem;
			height: 200px;
			overflow-y: auto;
			font-family: 'Courier New', monospace;
			font-size: 0.9rem;
			line-height: 1.4;
		}

		.log-entry {
			margin-bottom: 0.5rem;
			padding: 0.3rem 0;
		}

		.log-entry.info { color: var(--text-secondary); }
		.log-entry.warning { color: var(--warning-color); }
		.log-entry.error { color: var(--error-color); }
		.log-entry.success { color: var(--success-color); }

		/* Notification System */
		.notification {
			position: fixed;
			top: 20px;
			right: 20px;
			padding: 1rem 1.5rem;
			border-radius: 12px;
			color: white;
			font-weight: 500;
			z-index: 1000;
			transform: translateX(400px);
			transition: all 0.3s ease;
			max-width: 350px;
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
		}

		.notification.show {
			transform: translateX(0);
		}

		.notification.success {
			background: linear-gradient(45deg, var(--success-color), #43a047);
		}

		.notification.error {
			background: linear-gradient(45deg, var(--error-color), #d32f2f);
		}

		.notification.info {
			background: linear-gradient(45deg, var(--accent-color), #1976d2);
		}

		.notification.warning {
			background: linear-gradient(45deg, var(--warning-color), #f57c00);
		}

		/* Button Groups */
		.button-group {
			display: flex;
			gap: 1rem;
			flex-wrap: wrap;
			justify-content: center;
			margin-top: 1.5rem;
		}

		/* Connection retry styles */
		.connection-retry {
			background: rgba(255, 152, 0, 0.1);
			border: 1px solid rgba(255, 152, 0, 0.3);
			border-radius: 8px;
			padding: 1rem;
			margin: 1rem 0;
			text-align: center;
			color: var(--warning-color);
		}

		.retry-button {
			background: var(--warning-color);
			color: white;
			border: none;
			padding: 0.5rem 1rem;
			border-radius: 6px;
			cursor: pointer;
			margin-top: 0.5rem;
		}

		.retry-button:hover {
			background: #f57c00;
		}

		/* Responsive Design */
		@media (max-width: 768px) {
			.header-content {
				flex-direction: column;
				gap: 1rem;
			}
			
			.main-container {
				padding: 1rem;
				grid-template-columns: 1fr;
				height: calc(100vh - 100px);  /* Or whatever works */
			}
			
			.button-group {
				flex-direction: column;
			}
			
			.tab-navigation {
				overflow-x: auto;
				white-space: nowrap;
			}
		}

		/* Configuration Management Consolidated Styles */
		.config-management-consolidated {
			background: rgba(255, 255, 255, 0.08);
			border-radius: 16px;
			margin-bottom: 2rem;
			border: 2px solid var(--border-glass);
		}

		.config-status-display {
			background: rgba(0, 0, 0, 0.1);
			border-radius: 8px;
			padding: 1rem;
			margin-bottom: 1.5rem;
		}

		.current-file-status {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 1rem;
		}

		.status-item {
			display: flex;
			flex-direction: column;
			gap: 0.25rem;
		}

		.status-label {
			font-size: 0.9rem;
			color: var(--text-secondary);
			font-weight: 500;
		}

		.status-value {
			font-family: 'Courier New', monospace;
			background: rgba(255, 255, 255, 0.1);
			padding: 0.5rem;
			border-radius: 4px;
			font-size: 0.9rem;
		}

		.operation-group-title {
			font-size: 1.1rem;
			font-weight: 600;
			color: var(--text-primary);
			margin-bottom: 1rem;
			padding-bottom: 0.5rem;
			border-bottom: 1px solid var(--border-glass);
		}

		.config-file-operations {
			margin-bottom: 2rem;
		}

		.operation-group {
			margin-bottom: 1.5rem;
			padding: 1rem;
			background: rgba(255, 255, 255, 0.03);
			border-radius: 8px;
			border: 1px solid rgba(255, 255, 255, 0.1);
		}

		.operation-label {
			display: block;
			font-weight: 600;
			color: var(--text-primary);
			margin-bottom: 0.5rem;
		}

		.operation-controls {
			display: flex;
			flex-direction: column;
			gap: 0.5rem;
		}

		.input-group {
			display: flex;
			gap: 0.5rem;
			align-items: stretch;
		}

		.config-filename-input {
			flex: 1;
			padding: 0.75rem;
			border: 2px solid var(--border-glass);
			border-radius: 8px;
			background: var(--bg-glass);
			color: var(--text-primary);
			font-size: 0.9rem;
		}

		.template-select {
			min-width: 180px;
			padding: 0.75rem;
			border: 2px solid var(--border-glass);
			border-radius: 8px;
			background: var(--bg-glass);
			color: var(--text-primary);
		}

		.operation-btn {
			min-width: 100px;
			padding: 0.75rem 1rem;
			white-space: nowrap;
		}

		.operation-help {
			font-size: 0.8rem;
			color: var(--text-secondary);
			font-style: italic;
			margin-top: 0.25rem;
		}

		.config-actions-section {
			margin-bottom: 2rem;
		}

		.action-buttons-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			gap: 1rem;
		}

		.action-group {
			display: flex;
			flex-direction: column;
			gap: 0.5rem;
		}

		.action-btn {
			padding: 1rem;
			height: auto;
			display: flex;
			align-items: center;
			gap: 0.75rem;
			text-align: left;
		}

		.btn-content {
			display: flex;
			flex-direction: column;
			gap: 0.25rem;
		}

		.btn-title {
			font-weight: 600;
			font-size: 1rem;
		}

		.btn-subtitle {
			font-size: 0.8rem;
			opacity: 0.8;
			font-weight: normal;
		}

		.action-help {
			font-size: 0.8rem;
			color: var(--text-secondary);
			text-align: center;
		}

		.config-feedback-section {
			border-top: 1px solid var(--border-glass);
			padding-top: 1.5rem;
		}

		.config-status-container {
			background: rgba(0, 0, 0, 0.1);
			border-radius: 8px;
			padding: 1rem;
			position: relative;
		}

		.config-status-message {
			font-size: 0.9rem;
			color: var(--text-secondary);
		}

		.operation-progress {
			display: flex;
			align-items: center;
			gap: 0.5rem;
			color: var(--accent-color);
		}

		.progress-spinner {
			width: 16px;
			height: 16px;
			border: 2px solid var(--border-glass);
			border-top: 2px solid var(--accent-color);
			border-radius: 50%;
			animation: spin 1s linear infinite;
		}

		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

		.progress-text {
			font-size: 0.9rem;
		}

		/* Responsive Design */
		@media (max-width: 768px) {
			.current-file-status {
				grid-template-columns: 1fr;
			}
			
			.input-group {
				flex-direction: column;
			}
			
			.action-buttons-grid {
				grid-template-columns: 1fr;
			}
			
			.operation-btn {
				min-width: auto;
			}
		}

		/* Form validation error styles */
		.form-error {
		    border-color: var(--error-color) !important;
		    box-shadow: 0 0 10px rgba(244, 67, 54, 0.3) !important;
		}

		.error-text {
		    color: var(--error-color) !important;
		    font-weight: 600;
		}

		.help-text.error-text {
		    background: rgba(244, 67, 54, 0.1);
		    padding: 0.25rem 0.5rem;
		    border-radius: 4px;
		    margin-top: 0.5rem;
		}

		/* Audio Message Styles */
		.message.audio-message {
			background: linear-gradient(135deg, rgba(66, 165, 245, 0.1), rgba(66, 165, 245, 0.2));
			border: 2px solid rgba(66, 165, 245, 0.3);
			border-radius: 16px;
			padding: 1rem;
			margin: 0.5rem 0;
		}

		.audio-content {
			display: flex;
			flex-direction: column;
			gap: 0.75rem;
		}

		.audio-header {
			display: flex;
			align-items: center;
			gap: 0.5rem;
			margin-right: 0.5rem;
			text-transform: uppercase;
		}

		.message.incoming {
			border-left: 4px solid var(--accent-color);
			animation: messageSlideIn 0.4s ease;
		}

		.message.outgoing {
			border-right: 4px solid var(--success-color);
		}

		@keyframes messageSlideIn {
			from {
				opacity: 0;
				transform: translateX(-20px);
			}
			to {
				opacity: 1;
				transform: translateX(0);
			}
		}

		/* Reception Statistics */
		.reception-stats {
			background: rgba(255, 255, 255, 0.05);
			border-radius: 8px;
			padding: 1rem;
			margin-top: 1rem;
		}

		.reception-stats h4 {
			margin-bottom: 0.5rem;
			color: var(--text-primary);
			font-size: 1rem;
		}

		.reception-stats-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 0.5rem;
		}

		.reception-stat-item {
			text-align: center;
			padding: 0.5rem;
			background: rgba(255, 255, 255, 0.05);
			border-radius: 6px;
		}

		.reception-stat-label {
			display: block;
			font-size: 0.8rem;
			color: var(--text-secondary);
			margin-bottom: 0.25rem;
		}

		.reception-stat-value {
			font-size: 1.2rem;
			font-weight: 600;
			color: var(--accent-color);
		}

		/* Real-time Updates */
		.message-new {
			animation: messageHighlight 2s ease;
		}

		@keyframes messageHighlight {
			0% { background: rgba(66, 165, 245, 0.3); }
			100% { background: transparent; }
		}

		.audio-message-new .audio-icon {
			animation: pulseNew 1s ease 3;
		}

		@keyframes pulseNew {
			0%, 100% { transform: scale(1); }
			50% { transform: scale(1.3); }
		}

		/* Loading States */
		.audio-loading {
			display: flex;
			align-items: center;
			gap: 0.5rem;
			color: var(--text-secondary);
			font-style: italic;
		}

		.audio-loading::before {
			content: 'üîÑ';
			animation: spin 1s linear infinite;
		}

		/* Mobile Responsive */
		@media (max-width: 768px) {
			.audio-controls {
				flex-direction: column;
				gap: 0.5rem;
			}
			
			.audio-play-btn {
				width: 100%;
				justify-content: center;
			}
			
			.audio-controls-panel {
				padding: 0.75rem;
			}
			
			.control-group {
				font-size: 0.85rem;
			}
			
			.audio-permission-request {
				margin: 1rem;
				max-width: calc(100vw - 2rem);
			}
		}

		/* Dark Mode Enhancements */
		@media (prefers-color-scheme: dark) {
			.audio-waveform {
				background: rgba(0, 0, 0, 0.2);
			}
			
			.audio-duration {
				background: rgba(66, 165, 245, 0.15);
			}
			
			.control-group label {
				color: rgba(255, 255, 255, 0.7);
			}
			
			.control-group input[type="checkbox"]:checked + label {
				color: rgba(255, 255, 255, 0.9);
			}
		}

		/* Accessibility Enhancements */
		.audio-play-btn:focus {
			outline: 2px solid var(--accent-color);
			outline-offset: 2px;
		}

		.control-group input[type="checkbox"]:focus {
			outline: 2px solid var(--accent-color);
			outline-offset: 2px;
		}

		/* High contrast mode support */
		@media (prefers-contrast: high) {
			.message.audio-message {
				border-width: 3px;
			}
			
			.audio-play-btn {
				border: 2px solid white;
			}
			
			.message-type-indicator {
				border: 1px solid white;
			}
		}

		/* Reduced motion support */
		@media (prefers-reduced-motion: reduce) {
			.audio-icon,
			.audio-waveform::before,
			.messageSlideIn,
			.messageHighlight {
				animation: none;
			}
			
			.message.incoming {
				animation: none;
			}
		}

		/* Notification dot for new audio */
		.stat-item.has-new-audio .stat-value::after {
			content: '';
			display: inline-block;
			width: 8px;
			height: 8px;
			background: var(--error-color);
			border-radius: 50%;
			margin-left: 0.5rem;
			animation: pulse 1s infinite;
		}

		/* Status indicators */
		.connection-status.receiving {
			background: linear-gradient(45deg, var(--success-color), #43a047);
			animation: receivingPulse 1s ease infinite;
		}

		@keyframes receivingPulse {
			0%, 100% { opacity: 1; }
			50% { opacity: 0.7; }
		}

		.audio-icon {
			font-size: 1.2rem;
			animation: pulse-audio 2s infinite;
		}

		@keyframes pulse-audio {
			0%, 100% { opacity: 1; transform: scale(1); }
			50% { opacity: 0.7; transform: scale(1.1); }
		}

		.audio-from {
			color: var(--accent-color);
			font-weight: 600;
		}

		.audio-duration {
			background: rgba(66, 165, 245, 0.2);
			padding: 0.25rem 0.5rem;
			border-radius: 12px;
			font-size: 0.8rem;
			font-family: 'Courier New', monospace;
		}

		.audio-controls {
			display: flex;
			align-items: center;
			gap: 1rem;
		}

		.audio-play-btn {
			background: linear-gradient(45deg, var(--success-color), #43a047);
			border: none;
			border-radius: 8px;
			color: white;
			padding: 0.5rem 1rem;
			font-size: 0.9rem;
			cursor: pointer;
			transition: all 0.3s ease;
			display: flex;
			align-items: center;
			gap: 0.5rem;
		}

		.audio-play-btn:hover {
			transform: translateY(-2px);
			box-shadow: 0 8px 20px rgba(76, 175, 80, 0.4);
		}

		.audio-play-btn:disabled {
			opacity: 0.6;
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
		}

		.audio-waveform {
			flex: 1;
			height: 30px;
			background: rgba(255, 255, 255, 0.1);
			border-radius: 15px;
			position: relative;
			overflow: hidden;
		}

		.audio-waveform::before {
			content: '';
			position: absolute;
			top: 50%;
			left: 5px;
			right: 5px;
			height: 2px;
			background: linear-gradient(90deg, 
				transparent 0%, 
				var(--accent-color) 20%, 
				var(--accent-color) 80%, 
				transparent 100%);
			transform: translateY(-50%);
			animation: audio-wave 2s infinite;
		}

		@keyframes audio-wave {
			0%, 100% { opacity: 0.3; transform: translateY(-50%) scaleX(0.8); }
			50% { opacity: 1; transform: translateY(-50%) scaleX(1.2); }
		}

		/* Audio Controls Panel */
		.audio-controls-panel {
			background: rgba(255, 255, 255, 0.05);
			border-radius: 12px;
			padding: 1rem;
			margin-bottom: 1rem;
			border: 1px solid var(--border-glass);
		}

		.control-group {
			display: flex;
			align-items: center;
			margin-bottom: 0.5rem;
			padding: 0.25rem 0;
		}

		.control-group:last-child {
			margin-bottom: 0;
		}

		.control-group label {
			display: flex;
			align-items: center;
			gap: 0.5rem;
			cursor: pointer;
			color: var(--text-secondary);
			font-size: 0.9rem;
			user-select: none;
		}

		.control-group input[type="checkbox"] {
			accent-color: var(--accent-color);
			width: 16px;
			height: 16px;
			cursor: pointer;
		}

		.control-group input[type="checkbox"]:checked + label {
			color: var(--text-primary);
		}

		/* Audio Permission Request */
		.audio-permission-request {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: var(--bg-glass);
			backdrop-filter: blur(20px);
			border: 2px solid var(--border-glass);
			border-radius: 20px;
			padding: 2rem;
			z-index: 1000;
			box-shadow: var(--shadow-main);
			text-align: center;
			max-width: 400px;
			animation: slideInScale 0.3s ease;
		}

		@keyframes slideInScale {
			from {
				opacity: 0;
				transform: translate(-50%, -50%) scale(0.8);
			}
			to {
				opacity: 1;
				transform: translate(-50%, -50%) scale(1);
			}
		}

		.permission-content h3 {
			margin-bottom: 1rem;
			color: var(--text-primary);
			font-size: 1.3rem;
		}

		.permission-content p {
			margin-bottom: 1.5rem;
			color: var(--text-secondary);
			line-height: 1.5;
		}

		.permission-content .btn {
			margin: 0 0.5rem;
		}

		/* Enhanced Message Styles */
		.message-type-indicator {
			background: var(--accent-color);
			color: white;
			padding: 0.2rem 0.5rem;
			border-radius: 4px;
			font-size: 0.7rem;
			font-weight: 600;
		}

		/* Enhanced transmission message styling */
		.audio-message .message-type-indicator {
		    background: linear-gradient(45deg, #1976d2, #42a5f5);
		    padding: 0.2rem 0.6rem;
		    border-radius: 12px;
		    font-size: 0.7rem;
		    font-weight: 700;
		    letter-spacing: 0.5px;
		    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
		}

		.audio-packets {
		    background: rgba(255, 255, 255, 0.15);
		    padding: 0.2rem 0.5rem;
		    border-radius: 8px;
		    font-size: 0.75rem;
		    color: var(--text-secondary);
		    margin-left: 0.5rem;
		}

		/* Enhanced waveform visualization */
		.waveform-bars {
		    display: flex;
		    align-items: end;
		    gap: 2px;
		    height: 30px;
		    padding: 0 10px;
		}

		.waveform-bars .bar {
		    width: 3px;
		    background: linear-gradient(to top, var(--accent-color), rgba(66, 165, 245, 0.3));
		    border-radius: 2px 2px 0 0;
		    height: 20%;
		    transition: height 0.3s ease;
		    opacity: 0.7;
		}

		.waveform-bars .bar:nth-child(odd) {
		    background: linear-gradient(to top, #42a5f5, rgba(66, 165, 245, 0.5));
		}

		.waveform-bars .bar:hover {
		    opacity: 1;
		    transform: scaleY(1.1);
		}

		/* Transmission metadata styling */
		.transmission-meta {
		    font-size: 0.75rem;
		    color: var(--text-secondary);
		    font-style: italic;
		    margin-left: 0.5rem;
		}

		/* Enhanced audio controls */
		.audio-controls {
		    display: flex;
		    align-items: center;
		    gap: 1rem;
		    margin-top: 0.5rem;
		}

		.audio-play-btn {
		    background: linear-gradient(45deg, var(--success-color), #43a047);
		    border: none;
		    border-radius: 10px;
		    color: white;
		    padding: 0.6rem 1.2rem;
		    font-size: 0.85rem;
		    font-weight: 600;
		    cursor: pointer;
		    transition: all 0.3s ease;
		    display: flex;
		    align-items: center;
		    gap: 0.5rem;
		    min-width: 140px;
		    justify-content: center;
		    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
		}

		.audio-play-btn:hover:not(:disabled) {
		    transform: translateY(-2px);
		    box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
		    background: linear-gradient(45deg, #4caf50, #66bb6a);
		}

		.audio-play-btn:disabled {
		    opacity: 0.7;
		    cursor: not-allowed;
		    transform: none;
		    box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
		    background: linear-gradient(45deg, #9e9e9e, #757575);
		}

		/* Transmission status indicators */
		.transmission-status {
		    display: flex;
		    align-items: center;
		    gap: 0.5rem;
		    margin-bottom: 1rem;
		    padding: 0.75rem;
		    background: rgba(255, 255, 255, 0.05);
		    border-radius: 8px;
		    border-left: 4px solid var(--accent-color);
		}

		.transmission-status.active {
		    border-left-color: var(--warning-color);
		    background: rgba(255, 152, 0, 0.1);
		}

		.transmission-status.completed {
		    border-left-color: var(--success-color);
		    background: rgba(76, 175, 80, 0.1);
		}

		/* Enhanced message header for transmissions */
		.audio-header {
		    display: flex;
		    align-items: center;
		    gap: 0.5rem;
		    flex-wrap: wrap;
		    margin-bottom: 0.5rem;
		}

		.audio-icon {
		    font-size: 1.4rem;
		    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
		    animation: none; /* Remove the pulsing for transmissions */
		}

		.audio-from {
		    color: var(--accent-color);
		    font-weight: 700;
		    font-size: 1rem;
		    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
		}

		.audio-duration {
		    background: linear-gradient(45deg, rgba(66, 165, 245, 0.2), rgba(66, 165, 245, 0.3));
		    padding: 0.3rem 0.8rem;
		    border-radius: 15px;
		    font-size: 0.8rem;
		    font-family: 'Courier New', monospace;
		    font-weight: 600;
		    border: 1px solid rgba(66, 165, 245, 0.3);
		    box-shadow: 0 2px 8px rgba(66, 165, 245, 0.2);
		}

		/* Transmission animation */
		@keyframes transmissionComplete {
		    0% { 
		        background: rgba(76, 175, 80, 0.1);
		        transform: scale(1);
		    }
		    50% { 
		        background: rgba(76, 175, 80, 0.2);
		        transform: scale(1.02);
		    }
		    100% { 
		        background: transparent;
		        transform: scale(1);
		    }
		}

		.audio-message.transmission-complete {
		    animation: transmissionComplete 1s ease;
		}

		/* Status panel enhancements for transmissions */
		.transmission-stats {
		    display: grid;
		    grid-template-columns: 1fr 1fr;
		    gap: 0.5rem;
		    margin-top: 1rem;
		    padding: 1rem;
		    background: rgba(255, 255, 255, 0.05);
		    border-radius: 8px;
		}

		.transmission-stat {
		    text-align: center;
		    padding: 0.5rem;
		    background: rgba(255, 255, 255, 0.03);
		    border-radius: 6px;
		}

		.transmission-stat-label {
		    display: block;
		    font-size: 0.8rem;
		    color: var(--text-secondary);
		    margin-bottom: 0.25rem;
		}

		.transmission-stat-value {
		    font-size: 1.1rem;
		    font-weight: 600;
		    color: var(--accent-color);
		}

		/* Mobile responsive adjustments */
		@media (max-width: 768px) {
		    .audio-header {
		        flex-direction: column;
		        align-items: flex-start;
		        gap: 0.3rem;
		    }
		    
		    .audio-controls {
		        flex-direction: column;
		        gap: 0.75rem;
		    }
		    
		    .audio-play-btn {
		        width: 100%;
		        min-width: auto;
		    }
		    
		    .waveform-bars {
		        height: 25px;
		    }
		    
		    .transmission-stats {
		        grid-template-columns: 1fr;
		    }
		}






/* Add these CSS rules to the existing styles in index.html */

/* Enhanced Audio Message Styles - Both Directions */
.message.audio-message {
	background: linear-gradient(135deg, rgba(66, 165, 245, 0.1), rgba(66, 165, 245, 0.2));
	border: 2px solid rgba(66, 165, 245, 0.3);
	border-radius: 16px;
	padding: 1rem;
	margin: 0.5rem 0;
}

/* Incoming Audio Messages (existing - keep as is) */
.message.incoming.audio-message {
	background: linear-gradient(135deg, rgba(66, 165, 245, 0.1), rgba(66, 165, 245, 0.2));
	border: 2px solid rgba(66, 165, 245, 0.3);
	border-left: 4px solid var(--accent-color);
	align-self: flex-start;
	animation: messageSlideIn 0.4s ease;
}

/* NEW: Outgoing Audio Messages */
.message.outgoing.audio-message {
	background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.2));
	border: 2px solid rgba(76, 175, 80, 0.3);
	border-right: 4px solid var(--success-color);
	align-self: flex-end;
	margin-left: auto;
	animation: messageSlideInRight 0.4s ease;
}

/* NEW: Slide-in animation for outgoing messages */
@keyframes messageSlideInRight {
	from {
		opacity: 0;
		transform: translateX(20px);
	}
	to {
		opacity: 1;
		transform: translateX(0);
	}
}

/* Enhanced waveform for outgoing messages */
.message.outgoing.audio-message .waveform-bars .bar {
	background: linear-gradient(to top, var(--success-color), rgba(76, 175, 80, 0.3));
}

.message.outgoing.audio-message .waveform-bars .bar:nth-child(odd) {
	background: linear-gradient(to top, #4caf50, rgba(76, 175, 80, 0.5));
}

/* Enhanced audio controls for outgoing */
.message.outgoing.audio-message .audio-play-btn {
	background: linear-gradient(45deg, var(--success-color), #43a047);
	box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
}

.message.outgoing.audio-message .audio-play-btn:hover:not(:disabled) {
	background: linear-gradient(45deg, #4caf50, #66bb6a);
	box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
}

/* Different meta styling for outgoing */
.message.outgoing.audio-message .message-meta {
	text-align: right;
}

.message.outgoing.audio-message .transmission-meta {
	color: var(--success-color);
	font-weight: 600;
}


/* Responsive adjustments */
@media (max-width: 768px) {
	.message.outgoing.audio-message {
		margin-left: 0;
		align-self: stretch;
	}
	
	.message.outgoing.audio-message .message-meta {
		text-align: left;
	}
}









	</style>
</head>
<body>
	<!-- Screen reader announcements -->
	<div id="sr-announcements" aria-live="polite" aria-atomic="true" class="sr-only"></div>
	<div id="sr-status" aria-live="assertive" aria-atomic="true" class="sr-only"></div>
	
	<header role="banner" class="main-header">
		<div class="header-content">
			<h1 class="app-title">
				<span class="app-icon" aria-hidden="true">üìª</span>
				Opulent Voice Radio
			</h1>
			
			<div class="connection-status" id="connection-status" role="status" aria-live="polite">
				<span class="status-indicator connecting" aria-label="Connection status"></span>
				<span class="status-text">Connecting...</span>
			</div>
			
			<div class="header-controls">
				<nav class="tab-navigation" role="tablist">
					<button class="tab-button active" 
							role="tab" 
							aria-selected="true" 
							aria-controls="chat-panel"
							id="chat-tab"
							onclick="switchTab('chat')">
						üí¨ Chat
					</button>
					<button class="tab-button" 
							role="tab" 
							aria-selected="false" 
							aria-controls="config-panel"
							id="config-tab"
							onclick="switchTab('config')">
						‚öôÔ∏è Configuration
					</button>
				</nav>
			</div>
		</div>
	</header>

	<main id="main-content" role="main" class="main-container">
		
		<!-- Chat Panel (Default View) -->
		<div id="chat-panel" class="panel" role="tabpanel" aria-labelledby="chat-tab">
			<div class="panel-title">
				<span class="panel-icon">üí¨</span>
				Communications
			</div>
			
			<div class="chat-container">
				<div class="chat-header">
					<div class="station-info">
						<span>Station: </span>
						<strong id="current-station">CONNECTING...</strong>
					</div>
					
					<button id="ptt-button" 
							class="ptt-button" 
							aria-pressed="false"
							aria-describedby="ptt-status"
							disabled>
						<span aria-hidden="true">üé§</span>
						<span class="ptt-text">PTT</span>
					</button>
				</div>
				
				<div id="message-history" 
					 class="message-history" 
					 role="log" 
					 aria-live="polite" 
					 aria-label="Message history"
					 tabindex="0">
					<div class="message system">
						<div>Welcome to Opulent Voice Radio Interface</div>
						<div class="message-meta">
							<span>System</span>
							<span id="welcome-time"></span>
						</div>
					</div>
				</div>
				
				<!-- Connection retry panel (initially hidden) -->
				<div id="connection-retry" class="connection-retry" style="display: none;">
					<div>Connection lost to radio system</div>
					<button class="retry-button" onclick="attemptReconnect()">Retry Connection</button>
				</div>
				<form id="message-form" class="message-input-form">
					<div class="input-container">
						<label for="message-input" class="sr-only">Message to send</label>
						<textarea id="message-input"
							class="message-input"
							placeholder="Type your message..."
							rows="1"
							disabled></textarea>
					</div>
					<button type="submit"
						class="send-button"
						disabled>
					Send
					</button>
				</form>				
			</div>
		</div>

		<!-- REVISED CONFIGURATION PANEL -->
		<div id="config-panel" class="config-tabs" role="tabpanel" aria-labelledby="config-tab">
			<div class="panel-title">
				<span class="panel-icon">‚öôÔ∏è</span>
				Configuration Management
			</div>
			
			<!-- CONSOLIDATED CONFIGURATION MANAGEMENT SECTION -->
			<div class="config-section config-management-consolidated">
				<div class="section-header">
					<span aria-hidden="true">üìÅ</span>
					Configuration Management
				</div>
				
				<!-- Current Configuration Status -->
				<div class="config-status-display">
					<div class="current-file-status">
						<div class="status-item">
							<label class="status-label">üìÑ Active Configuration File:</label>
							<span id="current-config-file" class="status-value">No file loaded</span>
						</div>
					</div>
				</div>
				
				<!-- File Operations Section -->
				<div class="config-file-operations">
					<h4 class="operation-group-title">üìÇ File Operations</h4>
					
					<!-- Load Configuration -->
					<div class="operation-group">
						<label class="operation-label">Load Configuration</label>
						<div class="operation-controls">
							<div class="input-group">
								<input type="text" 
									   id="load-config-filename" 
									   placeholder="Leave empty for auto-discovery"
									   class="config-filename-input"
									   aria-label="Configuration file to load">
								<button class="btn btn-primary operation-btn" onclick="loadConfigFile()">
									<span aria-hidden="true">üìÇ</span>
									Load
								</button>
							</div>
							<div class="operation-help">
								Auto-discovery searches: opulent_voice.yaml ‚Üí config/opulent_voice.yaml ‚Üí ~/.config/opulent_voice/config.yaml
							</div>
						</div>
					</div>
					
					<!-- Save Configuration -->
					<div class="operation-group">
						<label class="operation-label">Save Configuration</label>
						<div class="operation-controls">
							<div class="input-group">
								<input type="text" 
									   id="save-config-filename" 
									   placeholder="Leave empty to save to original file"
									   class="config-filename-input"
									   aria-label="Configuration file to save to">
								<button class="btn btn-success operation-btn" onclick="saveConfigFile()">
									<span aria-hidden="true">üíæ</span>
									Save
								</button>
							</div>
							<div class="operation-help">
								Saves current form settings to file. Empty filename saves to original loaded file.
							</div>
						</div>
					</div>
					


<!-- Create Template Configuration -->
<div class="operation-group">
    <label class="operation-label">Create Template Configuration</label>
    <div class="operation-controls">
        <div class="input-group">
            <input type="text" 
                   id="create-config-filename" 
                   placeholder="opulent-voice.yaml"
                   class="config-filename-input"
                   aria-label="Template configuration filename">
            <button class="btn operation-btn" onclick="createConfigFileEnhanced()">
                <span aria-hidden="true">üìÑ</span>
                Create Template
            </button>
        </div>
        <div class="operation-help">
            Creates a sample configuration with comments and examples
        </div>
    </div>
</div>






				</div>
				
				<!-- Configuration Actions Section -->
				<div class="config-actions-section">
					<h4 class="operation-group-title">‚öôÔ∏è Configuration Actions</h4>
					
					<div class="action-buttons-grid">
						<!-- Apply to System -->
						<div class="action-group">
							<button class="btn btn-primary action-btn" onclick="applyConfig()">
								<span aria-hidden="true">‚úÖ</span>
								<div class="btn-content">
									<div class="btn-title">Apply Changes</div>
									<div class="btn-subtitle">Update running system</div>
								</div>
							</button>
							<div class="action-help">
								Applies current form settings to the running radio system (does not save to file)
							</div>
						</div>
						
						<!-- Test System -->
						<div class="action-group">
							<button class="btn action-btn" onclick="testConnection()">
								<span aria-hidden="true">üß™</span>
								<div class="btn-content">
									<div class="btn-title">Test System</div>
									<div class="btn-subtitle">Validate configuration</div>
								</div>
							</button>
							<div class="action-help">
								Tests network, audio, GPIO, and validates current form settings
							</div>
						</div>
						
						<!-- Reset Form -->
						<div class="action-group">
							<button class="btn action-btn" onclick="resetToDefaults()">
								<span aria-hidden="true">üîÑ</span>
								<div class="btn-content">
									<div class="btn-title">Reset Form</div>
									<div class="btn-subtitle">Restore defaults</div>
								</div>
							</button>
							<div class="action-help">
								Resets all form fields to default values (does not affect saved files)
							</div>
						</div>
					</div>
				</div>
				
				<!-- Status and Feedback Section -->
				<div class="config-feedback-section">
					<h4 class="operation-group-title">üìä Status</h4>
					<div class="config-status-container">
						<div id="config-status" class="config-status-message">
							Ready to manage configuration files and settings
						</div>
						<div id="config-operation-progress" class="operation-progress" style="display: none;">
							<div class="progress-spinner"></div>
							<span class="progress-text">Processing...</span>
						</div>
					</div>
				</div>
			</div>
			
			<!-- EXISTING CONFIGURATION SECTIONS CONTINUE HERE -->
			<div class="config-grid">
				<!-- Station Configuration -->
				<div class="config-section">
					<div class="section-header">
						<span aria-hidden="true">üì°</span>
						Station Settings
					</div>
					
					<div class="form-group">
						<label for="callsign">Callsign *</label>
						<input type="text" 
							   id="callsign" 
							   placeholder="N0CALL" 
							   maxlength="10" 
							   required
							   aria-describedby="callsign-help">
						<div id="callsign-help" class="help-text">
							Amateur radio callsign (A-Z, 0-9, -, /, .)
						</div>
					</div>
				</div>

				<!-- Network Configuration -->
				<div class="config-section">
					<div class="section-header">
						<span aria-hidden="true">üåê</span>
						Network Settings
					</div>
					
					<div class="form-group">
						<label for="target-ip">Target IP Address</label>
						<input type="text" 
							   id="target-ip" 
							   placeholder="192.168.2.152"
							   aria-describedby="target-ip-help">
						<div id="target-ip-help" class="help-text">
							IP address of target system
						</div>
					</div>
					
					<div class="form-group">
						<label for="target-port">Target Port</label>
						<input type="number" 
							   id="target-port" 
							   placeholder="57372" 
							   min="1" 
							   max="65535"
							   aria-describedby="target-port-help">
						<div id="target-port-help" class="help-text">
							UDP port for radio communication
						</div>
					</div>
					
					<div class="form-group">
						<label for="listen-port">Listen Port</label>
						<input type="number" 
							   id="listen-port" 
							   placeholder="57372" 
							   min="1" 
							   max="65535"
							   aria-describedby="listen-port-help">
						<div id="listen-port-help" class="help-text">
							Local port for receiving messages
						</div>
					</div>
				</div>







				<!-- Target Device Type Configuration -->
				<div class="config-section">
					<div class="section-header">
						<span aria-hidden="true">üîß</span>
						Target Device Type Settings
					</div>
					
					<div class="form-group">
						<label for="target-type">Target Type</label>
						<select id="target-type" aria-describedby="target-type-help">
							<option value="computer">Computer (LAN/Internet)</option>
							<option value="modem">Modem (SDR/Radio)</option>
						</select>
						<div id="target-type-help" class="help-text">
							Affects keepalive and timeout behavior
						</div>
					</div>
					
					<div class="form-group">
						<label for="keepalive-interval">Keepalive Interval (seconds)</label>
						<input type="number" 
							   id="keepalive-interval" 
							   placeholder="2.0" 
							   min="0.5" 
							   max="60"
							   step="0.1"
							   aria-describedby="keepalive-help">
						<div id="keepalive-help" class="help-text">
							Keepalive timing for computer targets
						</div>
					</div>
				</div>

				<!-- GPIO Configuration -->
				<div class="config-section">
					<div class="section-header">
						<span aria-hidden="true">üîå</span>
						GPIO Settings (Raspberry Pi)
					</div>
					
					<div class="form-group">
						<label for="ptt-pin">PTT GPIO Pin</label>
						<input type="number" 
							   id="ptt-pin" 
							   placeholder="23" 
							   min="2" 
							   max="27"
							   aria-describedby="ptt-pin-help">
						<div id="ptt-pin-help" class="help-text">
							GPIO pin for PTT button
						</div>
					</div>
					
					<div class="form-group">
						<label for="led-pin">LED GPIO Pin</label>
						<input type="number" 
							   id="led-pin" 
							   placeholder="17" 
							   min="2" 
							   max="27"
							   aria-describedby="led-pin-help">
						<div id="led-pin-help" class="help-text">
							GPIO pin for PTT LED indicator
						</div>
					</div>
				</div>

				<!-- Debug Configuration -->
				<div class="config-section">
					<div class="section-header">
						<span aria-hidden="true">üêõ</span>
						Debug Settings
					</div>
					
					<div class="checkbox-group">
						<input type="checkbox" id="verbose-mode">
						<label for="verbose-mode">Verbose Debug Output</label>
					</div>
					
					<div class="checkbox-group">
						<input type="checkbox" id="quiet-mode">
						<label for="quiet-mode">Quiet Mode (Minimal Output)</label>
					</div>
					
					<div class="form-group">
						<label for="log-level">Log Level</label>
						<select id="log-level-config">
							<option value="DEBUG">Debug (All Messages)</option>
							<option value="INFO" selected>Info (Normal)</option>
							<option value="WARNING">Warning (Important Only)</option>
							<option value="ERROR">Error (Problems Only)</option>
						</select>
					</div>
				</div>
			</div>
		</div>

		<!-- Status Panel (Always Visible) -->
		<div class="panel">
			<div class="panel-title">
				<span class="panel-icon">üìä</span>
				System Status
			</div>
			
			<div class="status-grid">
				<div class="stat-item">
					<span class="stat-label">Connection</span>
					<span id="connection-stat" class="stat-value">CONNECTING</span>
				</div>
				
				<div class="stat-item">
					<span class="stat-label">Text Messages Sent</span>
					<span id="messages-sent" class="stat-value">0</span>
				</div>
				
				<div class="stat-item">
					<span class="stat-label">Text Messages Received</span>
					<span id="messages-received" class="stat-value">0</span>
				</div>
				
				<div class="stat-item">
					<span class="stat-label">Uptime</span>
					<span id="uptime" class="stat-value">00:00</span>
				</div>
			</div>
			
			<!-- System Log -->
			<div class="log-section">
				<h3>System Log</h3>
				<div class="log-controls">
					<select id="log-level" aria-label="Log level filter">
						<option value="all">All Messages</option>
						<option value="info">Info and Above</option>
						<option value="warning">Warnings and Errors</option>
						<option value="error">Errors Only</option>
					</select>
					
					<button class="btn" onclick="clearLog()">
						Clear Log
					</button>
				</div>
				
				<div id="system-log" 
					 class="system-log" 
					 role="log" 
					 aria-live="polite"
					 aria-label="System log messages"
					 tabindex="0">
				</div>
			</div>
		</div>
	</main>

	<!-- Notification system -->
	<div id="notification" class="notification"></div>

	<script>
		// Global application state
		let ws = null;
		let currentStation = 'CONNECTING...';
		let messageCount = { sent: 0, received: 0 };
		let startTime = Date.now();
		let pttActive = false;
		let currentConfig = {};
		let reconnectAttempts = 0;
		let maxReconnectAttempts = 10;
		let reconnectDelay = 1000; // Start with 1 second

		// Initialize welcome time
		document.getElementById('welcome-time').textContent = new Date().toLocaleTimeString();

		// TRANSMISSION-BASED storage for GUI
		let activeTransmissions = new Map(); // station_id -> current transmission data
		let completedTransmissions = []; // List of complete transmissions

		// Outgoing transmission storage
		let activeOutgoingTransmissions = new Map(); // station_id -> current outgoing transmission data
		let completedOutgoingTransmissions = []; // List of complete outgoing transmissions

		let maxCompletedTransmissions = 50; // Store last 50 complete transmissions

		// Keep individual packets for live audio only (small buffer)
		let liveAudioPackets = {}; // For real-time streaming
		let maxLivePackets = 200; // Small buffer for live audio

		// Global audio context for web audio
		let audioContext = null;
		let audioQueue = [];
		let isPlayingAudio = false;

		// Transmission management globals
		let transmissionTimeoutMs = 3000; // 3 seconds timeout for incomplete transmissions
		let maxTransmissions = 50; // Keep last 50 transmissions

		// FIXED: Enhanced connection management
		function connectWebSocket() {
			// Clear any existing connection
			if (ws) {
				ws.close();
				ws = null;
			}

			const wsUrl = `ws://${window.location.host}/ws`;
			addLogEntry(`Attempting to connect to ${wsUrl}`, 'info');
			
			try {
				ws = new WebSocket(wsUrl);
				
				// Set a connection timeout
				const connectionTimeout = setTimeout(() => {
					if (ws.readyState === WebSocket.CONNECTING) {
						addLogEntry('Connection timeout - retrying...', 'warning');
						ws.close();
					}
				}, 5000);

				ws.onopen = function(event) {
					clearTimeout(connectionTimeout);
					reconnectAttempts = 0;
					reconnectDelay = 1000;
					
					updateConnectionStatus(true);
					showNotification('Connected to Opulent Voice System', 'success');
					addLogEntry('WebSocket connection established', 'success');
					
					// Hide retry panel if visible
					document.getElementById('connection-retry').style.display = 'none';
					
					// Load initial data
					loadCurrentConfig();
					sendWebSocketMessage('get_message_history');
				};

				ws.onclose = function(event) {
					clearTimeout(connectionTimeout);
					updateConnectionStatus(false);
					
					// Only attempt reconnect if it wasn't a clean close
					if (event.code !== 1000 && reconnectAttempts < maxReconnectAttempts) {
						addLogEntry(`Connection closed (code: ${event.code}). Reconnecting in ${reconnectDelay/1000}s...`, 'warning');
						
						setTimeout(() => {
							reconnectAttempts++;
							reconnectDelay = Math.min(reconnectDelay * 1.5, 30000); // Max 30 seconds
							connectWebSocket();
						}, reconnectDelay);
					} else {
						addLogEntry('Connection failed - maximum retry attempts reached', 'error');
						showNotification('Connection failed. Check if the radio system is running.', 'error');
						document.getElementById('connection-retry').style.display = 'block';
					}
				};

				ws.onmessage = function(event) {
					try {
						const message = JSON.parse(event.data);
						handleWebSocketMessage(message);
					} catch (e) {
						addLogEntry(`Error parsing message: ${e.message}`, 'error');
					}
				};

				ws.onerror = function(error) {
					clearTimeout(connectionTimeout);
					addLogEntry('WebSocket error occurred', 'error');
					updateConnectionStatus(false);
				};

			} catch (error) {
				addLogEntry(`Failed to create WebSocket: ${error.message}`, 'error');
				updateConnectionStatus(false);
			}
		}

		// Manual reconnect function
		function attemptReconnect() {
			addLogEntry('Manual reconnection attempt...', 'info');
			reconnectAttempts = 0;
			reconnectDelay = 1000;
			document.getElementById('connection-retry').style.display = 'none';
			connectWebSocket();
		}

		function sendWebSocketMessage(action, data = {}) {
			if (ws && ws.readyState === WebSocket.OPEN) {
				try {
					const message = JSON.stringify({ action, data });
					ws.send(message);
					addLogEntry(`Sent: ${action}`, 'info');
					return true;
				} catch (error) {
					addLogEntry(`Error sending message: ${error.message}`, 'error');
					return false;
				}
			} else {
				addLogEntry('Cannot send message - not connected', 'warning');
				return false;
			}
		}

		// Tab switching functionality
		function switchTab(tabName) {
			document.querySelectorAll('.tab-button').forEach(btn => {
				btn.classList.remove('active');
				btn.setAttribute('aria-selected', 'false');
			});
			
			if (tabName === 'chat') {
				document.getElementById('chat-tab').classList.add('active');
				document.getElementById('chat-tab').setAttribute('aria-selected', 'true');
				document.getElementById('chat-panel').style.display = 'block';
				document.getElementById('config-panel').style.display = 'none';
			} else if (tabName === 'config') {
				document.getElementById('config-tab').classList.add('active');
				document.getElementById('config-tab').setAttribute('aria-selected', 'true');
				document.getElementById('chat-panel').style.display = 'none';
				document.getElementById('config-panel').style.display = 'block';
				
				if (ws && ws.readyState === WebSocket.OPEN) {
					console.log("üîç DEBUG: Requesting current config");
					sendWebSocketMessage('get_current_config');
				} else {
					console.log("üîç DEBUG: WebSocket not ready, can't request config");
				}
			}
			
			announceToScreenReader(`Switched to ${tabName} tab`);
		}

		// Connection status management with better state handling
		function updateConnectionStatus(connected) {
			const statusIndicator = document.querySelector('.status-indicator');
			const statusText = document.querySelector('.status-text');
			const connectionStat = document.getElementById('connection-stat');
			const pttButton = document.getElementById('ptt-button');
			const messageInput = document.getElementById('message-input');
			const sendButton = document.querySelector('.send-button');
			
			if (connected) {
				statusIndicator.className = 'status-indicator connected';
				statusText.textContent = 'Connected';
				connectionStat.textContent = 'ONLINE';
				connectionStat.style.color = 'var(--success-color)';
				
				// Enable chat controls
				pttButton.disabled = false;
				messageInput.disabled = false;
				sendButton.disabled = false;
				messageInput.placeholder = 'Type your message...';
			} else {
				statusIndicator.className = 'status-indicator disconnected';
				statusText.textContent = 'Disconnected';
				connectionStat.textContent = 'OFFLINE';
				connectionStat.style.color = 'var(--error-color)';
				currentStation = 'DISCONNECTED';
				document.getElementById('current-station').textContent = currentStation;
				
				// Disable chat controls
				pttButton.disabled = true;
				messageInput.disabled = true;
				sendButton.disabled = true;
				messageInput.placeholder = 'Connect to radio system to send messages...';
				
				// Reset PTT state
				if (pttActive) {
					handlePTTStateChange(false);
				}
			}
		}

		// Enhanced message handling
		function loadMessageHistory(messages) {
			const messageHistory = document.getElementById('message-history');
			
			// Keep welcome message
			const welcomeMessage = messageHistory.querySelector('.message.system');
			messageHistory.innerHTML = '';
			if (welcomeMessage) {
				messageHistory.appendChild(welcomeMessage);
			}
			
			// Add all messages from history
			messages.forEach(messageData => {
				let direction = 'incoming';
				let from = messageData.from;
				
				if (messageData.from === currentStation || messageData.direction === 'outgoing') {
					direction = 'outgoing';
					from = 'You';
				}
				
				const message = createMessageElement(
					messageData.content,
					direction,
					from,
					messageData.timestamp
				);
				messageHistory.appendChild(message);
			});
			
			scrollToBottom(messageHistory);
			addLogEntry(`Loaded ${messages.length} messages from history`, 'info');
		}

		function handleIncomingMessage(data) {
			const messageHistory = document.getElementById('message-history');
			
			// Don't display if this is our own message
			if (data.from === currentStation) {
				return;
			}
			
			const message = createMessageElement(data.content, 'incoming', data.from, data.timestamp);
			messageHistory.appendChild(message);
			scrollToBottom(messageHistory);
			
			messageCount.received++;
			document.getElementById('messages-received').textContent = messageCount.received;
			
			announceToScreenReader(`New message from ${data.from}: ${data.content}`);
			addLogEntry(`Message received from ${data.from}`, 'info');
		}

		function createMessageElement(content, direction, from, timestamp) {
			const messageEl = document.createElement('div');
			messageEl.className = `message ${direction}`;
			messageEl.setAttribute('role', 'log');
			messageEl.setAttribute('aria-live', 'polite');
			
			const contentEl = document.createElement('div');
			contentEl.className = 'message-content';
			contentEl.textContent = content;
			messageEl.appendChild(contentEl);
			
			const metaEl = document.createElement('div');
			metaEl.className = 'message-meta';
			
			const fromEl = document.createElement('span');
			fromEl.className = 'message-from';
			fromEl.textContent = direction === 'outgoing' ? 'You' : from;
			metaEl.appendChild(fromEl);
			
			const timeEl = document.createElement('span');
			timeEl.className = 'message-time';
			const date = new Date(timestamp);
			timeEl.textContent = date.toLocaleTimeString();
			timeEl.setAttribute('title', date.toLocaleString());
			metaEl.appendChild(timeEl);
			
			messageEl.appendChild(metaEl);
			return messageEl;
		}

		function scrollToBottom(element, smooth = true) {
			if (smooth) {
				element.scrollTo({
					top: element.scrollHeight,
					behavior: 'smooth'
				});
			} else {
				element.scrollTop = element.scrollHeight;
			}
		}

		// Message sending
		function sendMessage() {
			const messageInput = document.getElementById('message-input');
			const message = messageInput.value.trim();
			
			if (!message) return;
			
			if (ws && ws.readyState === WebSocket.OPEN) {
				const timestamp = new Date().toISOString();
				displayOutgoingMessage(message, timestamp);
				
				sendWebSocketMessage('send_text_message', { message });
				messageInput.value = '';
				messageInput.style.height = 'auto';
				
				addLogEntry(`Sent message: ${message.substring(0, 50)}...`, 'info');
			} else {
				showNotification('Cannot send message: not connected', 'error');
			}
		}

		function displayOutgoingMessage(content, timestamp) {
			const messageHistory = document.getElementById('message-history');
			const message = createMessageElement(content, 'outgoing', currentStation, timestamp);
			messageHistory.appendChild(message);
			scrollToBottom(messageHistory);
			
			messageCount.sent++;
			document.getElementById('messages-sent').textContent = messageCount.sent;
			
			announceToScreenReader(`You sent: ${content}`);
		}

		// PTT functionality
		function togglePTT() {
			if (pttActive) {
				deactivatePTT();
			} else {
				activatePTT();
			}
		}

		function activatePTT() {
			if (pttActive || !ws || ws.readyState !== WebSocket.OPEN) return;
			
			sendWebSocketMessage('ptt_pressed');
			handlePTTStateChange(true);
			addLogEntry('PTT activated', 'info');
		}

		function deactivatePTT() {
			if (!pttActive) return;
			
			sendWebSocketMessage('ptt_released');
			handlePTTStateChange(false);
			addLogEntry('PTT released', 'info');
		}

		function handlePTTStateChange(active) {
			pttActive = active;
			const pttButton = document.getElementById('ptt-button');
			const pttText = pttButton.querySelector('.ptt-text');
			
			if (active) {
				pttButton.classList.add('active');
				pttButton.setAttribute('aria-pressed', 'true');
				pttText.textContent = 'TRANSMITTING';
				announceToScreenReader('PTT activated - transmitting');
			} else {
				pttButton.classList.remove('active');
				pttButton.setAttribute('aria-pressed', 'false');
				pttText.textContent = 'PTT';
				announceToScreenReader('PTT released');
			}
		}

		// Configuration management
		function loadCurrentConfig() {
			sendWebSocketMessage('get_current_config');
		}

		function populateStatusFromData(status) {
			currentStation = status.station_id || 'DISCONNECTED';
			document.getElementById('current-station').textContent = currentStation;
			
			if (status.config) {
				document.getElementById('target-ip').value = status.config.target_ip || '';
				document.getElementById('target-port').value = status.config.target_port || '';
			}
		}

		function populateConfigFromData(config) {
			currentConfig = config;
			
			if (config.callsign) {
				document.getElementById('callsign').value = config.callsign;
				currentStation = config.callsign;
				document.getElementById('current-station').textContent = currentStation;
			}
			
			if (config.network) {
				if (config.network.target_ip) document.getElementById('target-ip').value = config.network.target_ip;
				if (config.network.target_port) document.getElementById('target-port').value = config.network.target_port;
			}
		}

		function applyConfig() {
			const config = gatherConfigData();
			if (validateConfig(config)) {
				sendWebSocketMessage('update_config', config);
				showNotification('Applying configuration...', 'info');

				// UPDATE: Also update the UI station ID immediately
				if (config.callsign) {
					currentStation = config.callsign;
					document.getElementById('current-station').textContent = currentStation;
				}
			}
		}


		function saveConfig() {
			const config = gatherConfigData();
			if (validateConfig(config)) {
				sendWebSocketMessage('save_config', config);
				showNotification('Saving configuration...', 'info');
			}
		}

		function gatherConfigData() {
			return {
				callsign: document.getElementById('callsign').value.trim(),
				network: {
					target_ip: document.getElementById('target-ip').value.trim(),
					target_port: parseInt(document.getElementById('target-port').value) || 57372
				}
			};
		}

		function validateConfig(config) {
			const errors = [];
			
			if (!config.callsign) {
				errors.push('Callsign is required');
			} else if (!/^[A-Z0-9\-\/.]+$/i.test(config.callsign)) {
				errors.push('Callsign contains invalid characters');
			}
			
			if (!config.network.target_ip) {
				errors.push('Target IP is required');
			}
			
			if (config.network.target_port < 1 || config.network.target_port > 65535) {
				errors.push('Target port must be between 1 and 65535');
			}
			
			if (errors.length > 0) {
				showNotification(errors.join('; '), 'error');
				return false;
			}
			
			return true;
		}

		function updateSystemStatus(data) {
			if (data.station_id) {
				currentStation = data.station_id;
				document.getElementById('current-station').textContent = currentStation;
			}
		}

		// Start a new transmission for a station
		function startNewTransmission(stationId, startTime) {
			console.log(`üé§ üìã Starting transmission from ${stationId}`);
			
			// End any previous incomplete transmission from this station
			if (activeTransmissions.has(stationId)) {
				console.log(`‚ö†Ô∏è Force-ending previous incomplete transmission from ${stationId}`);
				endTransmission(stationId, new Date().toISOString(), true);
			}
			
			const transmission = {
				stationId: stationId,
				startTime: startTime,
				endTime: null,
				audioPackets: [],
				totalDuration: 0,
				firstPacketTime: null,
				lastPacketTime: null,
				transmissionId: `tx_${stationId}_${Date.now()}`,
				incomplete: true,
				timeoutId: null
			};
			
			activeTransmissions.set(stationId, transmission);
			addLogEntry(`üì° Transmission started: ${stationId}`, 'success');
			
			// Show temporary indicator
			showNotification(`üìª ${stationId} started transmitting`, 'info');
		}

		// End a transmission and create UI bubble
		function endTransmission(stationId, endTime, forced = false) {
			const transmission = activeTransmissions.get(stationId);
			if (!transmission) {
				console.log(`‚ö†Ô∏è Tried to end transmission for ${stationId} but none active`);
				return;
			}
			
			// Clear timeout
			if (transmission.timeoutId) {
				clearTimeout(transmission.timeoutId);
			}
			
			transmission.endTime = endTime;
			transmission.incomplete = false;
			
			console.log(`üé§ üìã Ending transmission from ${stationId}:`);
			console.log(`   Packets: ${transmission.audioPackets.length}`);
			console.log(`   Duration: ${transmission.totalDuration}ms`);
			console.log(`   Forced: ${forced}`);
			
			// Move to completed transmissions
			completedTransmissions.push(transmission);
			activeTransmissions.delete(stationId);
			
			// Limit stored transmissions
			if (completedTransmissions.length > maxTransmissions) {
				completedTransmissions = completedTransmissions.slice(-maxTransmissions);
			}
			
			// Create UI bubble for the complete transmission
			if (transmission.audioPackets.length > 0) {
				createTransmissionUIBubble(transmission);
				const duration = (transmission.totalDuration / 1000).toFixed(1);
				addLogEntry(`üìª Transmission completed: ${stationId} (${transmission.audioPackets.length} packets, ${duration}s)`, 'success');
				showNotification(`üìª ${stationId} transmission complete (${duration}s)`, 'success');
			} else {
				console.log(`‚ö†Ô∏è No audio packets in transmission from ${stationId}`);
				addLogEntry(`‚ö†Ô∏è Empty transmission from ${stationId}`, 'warning');
			}
		}

		// Handle individual audio packets and add to active transmission
		function handleReceivedAudioPacket(audioData) {
			const stationId = audioData.from_station;
			
			console.log(`üé§ Audio packet from ${stationId}: ${audioData.duration_ms}ms`);
			
			// Get active transmission
			let transmission = activeTransmissions.get(stationId);
			
			if (!transmission) {
				// No active transmission - start one automatically (fallback for missing PTT_START)
				console.log(`üé§ ‚ö†Ô∏è Auto-starting transmission for ${stationId} (no PTT_START received)`);
				startNewTransmission(stationId, audioData.timestamp);
				transmission = activeTransmissions.get(stationId);
			}
			
			// Add packet to transmission
			transmission.audioPackets.push(audioData);
			transmission.totalDuration += audioData.duration_ms;
			transmission.lastPacketTime = audioData.timestamp;
			
			if (!transmission.firstPacketTime) {
				transmission.firstPacketTime = audioData.timestamp;
			}
			
			// Reset auto-timeout for this transmission
			resetTransmissionTimeout(stationId);
			
			// Continue real-time audio playback (don't interfere with live audio)
			playLiveAudio(audioData);
			
			console.log(`üé§ Added packet to transmission ${transmission.transmissionId} (${transmission.audioPackets.length} packets, ${transmission.totalDuration}ms total)`);
		}

		// Auto-timeout incomplete transmissions (fallback for missing PTT_STOP)
		function resetTransmissionTimeout(stationId) {
			const transmission = activeTransmissions.get(stationId);
			if (!transmission) return;
			
			// Clear existing timeout
			if (transmission.timeoutId) {
				clearTimeout(transmission.timeoutId);
			}
			
			// Set new timeout
			transmission.timeoutId = setTimeout(() => {
				console.log(`‚è∞ Auto-ending transmission from ${stationId} (timeout)`);
				endTransmission(stationId, new Date().toISOString(), true);
			}, transmissionTimeoutMs);
		}

		// Create UI bubble for completed transmission
		function createTransmissionUIBubble(transmission, direction = 'incoming') {
			const messageHistory = document.getElementById('message-history');
			const transmissionElement = document.createElement('div');			
			transmissionElement.className = `message ${direction} audio-message`;
			transmissionElement.setAttribute('data-transmission-id', transmission.transmissionId);
			
			const totalDurationSec = (transmission.totalDuration / 1000).toFixed(1);
			const packetCount = transmission.audioPackets.length;
			const startTime = new Date(transmission.startTime).toLocaleTimeString();

			// NEW: Different display based on direction
			const displayName = direction === 'outgoing' ? 'You' : transmission.stationId;			

			transmissionElement.innerHTML = `
				<div class="audio-content">
					<!--<div class="audio-header">
						<span class="audio-icon">üìª</span>
						<span class="message-type-indicator">TRANSMISSION</span>
						<span class="audio-from">${transmission.stationId}</span>
						<span class="audio-duration">${totalDurationSec}s</span>
						<span class="audio-packets">(${packetCount} packets)</span>
					</div>-->
					<div class="audio-controls">
						<button class="audio-play-btn" onclick="playCompleteTransmission('${transmission.transmissionId}')">
							‚ñ∂Ô∏è Replay
						</button>
						<div class="audio-waveform">
							<div class="waveform-bars">
								${'<div class="bar"></div>'.repeat(Math.min(packetCount, 20))}
							</div>
						</div>
					</div>
				</div>
				<div class="message-meta">
					<span>${displayName}</span>
					<span class="transmission-meta">${totalDurationSec}s</span>
					<span>${startTime}</span>
				</div>
			`;
			
			messageHistory.appendChild(transmissionElement);
			scrollToBottom(messageHistory);
			
			// Animate appearance
			transmissionElement.style.opacity = '0';
			transmissionElement.style.transform = 'translateY(20px)';
			setTimeout(() => {
				transmissionElement.style.transition = 'all 0.3s ease';
				transmissionElement.style.opacity = '1';
				transmissionElement.style.transform = 'translateY(0)';
			}, 10);
			
			// Animate waveform bars
			const bars = transmissionElement.querySelectorAll('.bar');
			bars.forEach((bar, index) => {
				const height = Math.random() * 80 + 20; // Random height 20-100%
				setTimeout(() => {
					bar.style.height = `${height}%`;
				}, index * 50);
			});
		}




function playCompleteTransmission(transmissionId) {
    console.log(`üéµ TRANSMISSION PLAYBACK: Request for ${transmissionId}`);
    
    // DEBUG: Show what's in storage
    console.log(`üîç STORAGE DEBUG: Looking for transmission ${transmissionId}`);
    console.log(`üîç STORAGE DEBUG: Incoming transmissions:`, completedTransmissions.map(t => t.transmissionId));
    console.log(`üîç STORAGE DEBUG: Outgoing transmissions:`, completedOutgoingTransmissions.map(t => t.transmissionId));
    
    // Search in both incoming and outgoing completed transmissions
    let transmission = completedTransmissions.find(t => t.transmissionId === transmissionId);
    let direction = 'incoming';
    
    if (!transmission) {
        transmission = completedOutgoingTransmissions.find(t => t.transmissionId === transmissionId);
        direction = 'outgoing';
        console.log(`üîç STORAGE DEBUG: Found in outgoing:`, transmission ? 'YES' : 'NO');
    }
    
    if (!transmission) {
        console.error(`‚ùå Transmission ${transmissionId} not found in incoming or outgoing`);
        showNotification('Transmission not found', 'error');
        return;
    }
    
    console.log(`üéµ PLAYBACK: Found ${direction} transmission with ${transmission.audioPackets.length} packets`);
    
    // Update button state immediately
    const button = document.querySelector(`[data-transmission-id="${transmissionId}"] .audio-play-btn`);
    if (button) {
        const directionText = direction === 'outgoing' ? 'your own' : transmission.stationId + "'s";
        button.textContent = `‚è≥ Requesting playback of ${directionText} message...`;
        button.disabled = true;
    }
    
    // Send request to Python backend for CLI speaker playback
    sendWebSocketMessage('request_transmission_playback', { 
        transmission_id: transmissionId,
        station_id: transmission.stationId,
        start_time: transmission.startTime,
        duration_ms: transmission.totalDuration,
        direction: direction  // NEW: Include direction in request
    });
    
    const duration = (transmission.totalDuration / 1000).toFixed(1);
    const directionText = direction === 'outgoing' ? 'your own' : transmission.stationId + "'s";
    showNotification(`üéµ Requesting ${directionText} CLI playback (${duration}s)`, 'info');
    addLogEntry(`üéµ CLI playback request: ${directionText} transmission (${duration}s)`, 'info');
}








	// Also update the playCompleteTransmission function to show clear messaging:
	function playCompleteTransmission_before_incoming_added(transmissionId) {
		const transmission = completedTransmissions.find(t => t.transmissionId === transmissionId);
		if (!transmission) {
			console.error(`‚ùå Transmission ${transmissionId} not found`);
			showNotification('Transmission not found', 'error');
			return;
		}
		
		console.log(`üéµ OPTION A REQUEST: Playing transmission ${transmissionId}`);
		console.log(`   Method: CLI speakers (same as live audio)`);
		console.log(`   Audio packets: ${transmission.audioPackets.length}`);
		console.log(`   Station: ${transmission.stationId}`);
		console.log(`   Duration: ${transmission.totalDuration}ms`);
		
		// Update button state immediately
		const button = document.querySelector(`[data-transmission-id="${transmissionId}"] .audio-play-btn`);
		if (button) {
			button.textContent = '‚è≥ Requesting CLI playback...';
			button.disabled = true;
		}
		
		// Send request to Python backend for CLI speaker playback
		sendWebSocketMessage('request_transmission_playback', { 
			transmission_id: transmissionId,
			station_id: transmission.stationId,
			start_time: transmission.startTime,
			duration_ms: transmission.totalDuration
		});
		
		const duration = (transmission.totalDuration / 1000).toFixed(1);
		showNotification(`üéµ Requesting ${transmission.stationId} CLI playback (${duration}s)`, 'info');
		addLogEntry(`üéµ CLI playback request: ${transmission.stationId} (${duration}s)`, 'info');
	}
















		// Play back a complete transmission
		function playCompleteTransmission_removed(transmissionId) {
			const transmission = completedTransmissions.find(t => t.transmissionId === transmissionId);
			if (!transmission) {
				console.error(`‚ùå Transmission ${transmissionId} not found`);
				showNotification('Transmission not found', 'error');
				return;
			}
			
			console.log(`üéµ TRANSMISSION PLAYBACK DEBUG: Playing transmission ${transmissionId}`);
			console.log(`   Audio packets: ${transmission.audioPackets.length}`);
			console.log(`   First packet audio_id: ${transmission.audioPackets[0]?.audio_id}`);
			console.log(`   Station: ${transmission.stationId}`);
			console.log(`   Duration: ${transmission.totalDuration}ms`);
			
			// Update button state
			const button = document.querySelector(`[data-transmission-id="${transmissionId}"] .audio-play-btn`);
			if (button) {
				button.textContent = '‚è∏Ô∏è Playing...';
				button.disabled = true;
				
				// Re-enable after estimated duration
				setTimeout(() => {
					button.textContent = '‚ñ∂Ô∏è Replay';
					button.disabled = false;
				}, transmission.totalDuration + 500); // Add 500ms buffer
			}
			
			// FIXED: Request transmission playback instead of individual packet playback
			console.log(`üéµ TRANSMISSION PLAYBACK DEBUG: Requesting transmission playback from server`);
			sendWebSocketMessage('request_transmission_playback', { 
				transmission_id: transmissionId,
				station_id: transmission.stationId,
				start_time: transmission.startTime,
				duration_ms: transmission.totalDuration
			});
			
			const duration = (transmission.totalDuration / 1000).toFixed(1);
			showNotification(`üéµ Playing transmission from ${transmission.stationId} (${duration}s)`, 'info');
			addLogEntry(`Playing transmission: ${transmission.stationId} (${transmission.totalDuration}ms)`, 'info');
		}










		// Continue real-time audio (don't interfere with live audio)
		function playLiveAudio(audioData) {
			// This maintains the existing real-time audio functionality
			// The live audio stream should continue working as before
			
			// Only update statistics, don't create UI bubbles for individual packets
			updateAudioReceptionStats(audioData);
			
			// Continue with existing live audio processing if auto-play is enabled
			if (document.getElementById('auto-play-audio')?.checked) {
				// Note: Individual packet playback disabled - only transmission playback now
				console.log(`üîä Live audio from ${audioData.from_station} continues playing`);
			}
		}












		// Enhanced WebSocket message handler with transmission grouping AI!!!
		function handleWebSocketMessage(message) {

			// DEBUG: Log ALL message types
			console.log('üîç ALL WEBSOCKET MESSAGES:', message.type, message.data);


			console.log('üîç WebSocket message received:', message.type);
			addLogEntry(`Received: ${message.type}`, 'info');

			switch (message.type) {
				case 'initial_status':
					populateStatusFromData(message.data);
					if (message.data.message_history) {
						loadMessageHistory(message.data.message_history);
					}
					break;
					
				//case 'current_config':   // duplicate case
				//	populateConfigFromData(message.data);
				//	break;
					
				case 'message_received':
					handleIncomingMessage(message.data);
					break;
					
				case 'message_sent':
					addLogEntry('Message confirmed sent', 'success');
					break;
					
				case 'message_history':
					loadMessageHistory(message.data);
					break;
					
				case 'ptt_state_changed':
					handlePTTStateChange(message.data.active);
					break;
					
				case 'status_update':
					updateSystemStatus(message.data);
					break;
					
				case 'error':
					showNotification(message.message || 'An error occurred', 'error');
					addLogEntry(`Error: ${message.message}`, 'error');
					break;
					
				// Enhanced config messages
				case 'config_loaded':
				case 'config_saved':
				case 'config_updated':
				case 'config_created':
				case 'config_not_found':
				case 'config_validation_warning':
				case 'connection_test_result':
				case 'connection_test_with_form_result':
					handleEnhancedConfigMessage(message);
					break;
					
				// *** NEW: CONTROL MESSAGE HANDLING FOR PTT BOUNDARIES ***
				case 'control_received':
					console.log('üéõÔ∏è Control message received:', message.data);
					handleControlMessage(message.data);
					break;
					
				// *** MODIFIED: AUDIO RECEPTION - Group by transmission ***
				case 'audio_received':
					console.log('üé§ Audio packet received:', message.data);
					handleReceivedAudioPacket(message.data);
					break;

				case 'transmission_started':
					console.log('üì° TRANSMISSION: Received transmission_started');
					const startData = message.data;
					startNewTransmissionFromServer(startData.station_id, startData.start_time, startData.transmission_id);
					break;
				
				case 'transmission_ended':
					console.log('üì° TRANSMISSION: Received transmission_ended');
					const endData = message.data;
					endTransmissionFromServer(endData.station_id, endData.end_time, endData.transmission_id);
					break;

				case 'transmission_audio_data':
					console.log('üéµ TRANSMISSION AUDIO: Received actual audio data');
					handleTransmissionAudioData(message.data);
					break;
					
				case 'audio_stream_data':
					handleAudioStreamData(message.data);
					break;
					
				case 'audio_playback_data':
					console.log('üéµ JS AUDIO PLAYBACK RESPONSE: Server responded with audio data');
					console.log('   Audio data:', message.data);
					handleAudioPlaybackData(message.data);
					break;
					
				case 'reception_stats':
					updateReceptionStats(message.data);
					break;




		case 'transmission_playback_started':
			console.log('üéµ OPTION A SUCCESS: Transmission playback started via CLI speakers');
			const playbackData = message.data;
			
			// Update ONLY the specific transmission button
			const transmissionId = playbackData.transmission_id;
			if (transmissionId) {
				const transmissionButton = document.querySelector(`[data-transmission-id="${transmissionId}"] .audio-play-btn`);
				if (transmissionButton) {
					// Set to playing state
					transmissionButton.textContent = 'üîä Playing via CLI speakers...';
					transmissionButton.disabled = true;
					console.log(`üîß Updated transmission button ${transmissionId} to playing state`);
					
					// Re-enable after duration plus buffer - FIXED: Always reset to proper text
					setTimeout(() => {
						transmissionButton.textContent = '‚ñ∂Ô∏è Replay';  // ‚Üê Always reset to this
						transmissionButton.disabled = false;
						console.log(`üîß Reset transmission button ${transmissionId} to ready state`);
					}, playbackData.duration_ms + 1000);
				} else {
					console.warn(`‚ö†Ô∏è Could not find transmission button for playback response ${transmissionId}`);
				}
			}
			
			// Show detailed success notification
			const duration = (playbackData.duration_ms / 1000).toFixed(1);
			const deviceInfo = `device ${playbackData.device_index}`;
			const queueInfo = playbackData.queue_size > 0 ? ` [${playbackData.queue_size} in queue]` : '';
			const bytesInfo = playbackData.audio_bytes ? ` (${(playbackData.audio_bytes/1024).toFixed(1)}KB)` : '';
			
			showNotification(`üîä Playing ${playbackData.from_station} via CLI speakers (${deviceInfo}) - ${duration}s${queueInfo}`, 'success');
			addLogEntry(`‚úÖ CLI playback: ${playbackData.from_station} ‚Üí ${deviceInfo} (${playbackData.total_segments} segments)${bytesInfo}`, 'success');
			break;



		case 'transmission_playback_error':
			console.log('üéµ OPTION A ERROR: Transmission playback failed');
			const errorData = message.data;
			
			// Re-enable button with proper text
			if (errorData.transmission_id) {
				const button = document.querySelector(`[data-transmission-id="${errorData.transmission_id}"] .audio-play-btn`);
				if (button) {
					button.textContent = '‚ñ∂Ô∏è Replay';  // ‚Üê Always reset to this
					button.disabled = false;
				}
			}
			
			showNotification(`‚ùå CLI playback failed: ${errorData.error}`, 'error');
			addLogEntry(`‚ùå CLI playback error: ${errorData.error}`, 'error');
			break;




     // NEW: Outgoing transmission handling
        case 'outgoing_transmission_started':
            console.log('üì§ OUTGOING: Received outgoing_transmission_started');
            const outStartData = message.data;
            startNewOutgoingTransmission(outStartData.station_id, outStartData.start_time, outStartData.transmission_id);
            break;
        
        case 'outgoing_transmission_ended':
            console.log('üì§ OUTGOING: Received outgoing_transmission_ended');
            const outEndData = message.data;
            endOutgoingTransmission(outEndData.station_id, outEndData.end_time, outEndData.transmission_id);
            break;

        case 'outgoing_audio_received':
            console.log('üì§ OUTGOING AUDIO: Received outgoing audio packet');
            handleOutgoingAudioPacket(message.data);
            break;
















				default:
					// Try enhanced config handler for any unhandled messages
					handleEnhancedConfigMessage(message);
    
					// Only log as unknown if it's NOT a config-related message
					if (!message.type.includes('config') && !message.type.includes('connection_test')) {
						console.warn('üîç Unknown message type:', message.type);
						addLogEntry(`Unknown message type: ${message.type}`, 'warning');
					}
					break;
			}
		}












		// Handle PTT control messages to define transmission boundaries
		function handleControlMessage(controlData) {
			const stationId = controlData.from;
			const controlMessage = controlData.content;
			const timestamp = controlData.timestamp;
			
			console.log(`üéõÔ∏è JS CONTROL DEBUG: Control received from ${stationId}: ${controlMessage}`);
			
			if (controlMessage === 'PTT_START') {
				console.log(`üéõÔ∏è JS CONTROL DEBUG: Starting transmission for ${stationId}`);
				startNewTransmission(stationId, timestamp);
			} else if (controlMessage === 'PTT_STOP') {
				console.log(`üéõÔ∏è JS CONTROL DEBUG: Ending transmission for ${stationId}`);
				endTransmission(stationId, timestamp);
			}
		}

		function startNewTransmissionFromServer(stationId, startTime, transmissionId) {
			console.log(`üì° SERVER TRANSMISSION START: ${transmissionId} from ${stationId}`);
			
			// End any previous incomplete transmission from this station
			if (activeTransmissions.has(stationId)) {
				console.log(`‚ö†Ô∏è Force-ending previous incomplete transmission from ${stationId}`);
				const oldTransmission = activeTransmissions.get(stationId);
				endTransmissionFromServer(stationId, new Date().toISOString(), oldTransmission.transmissionId);
			}
			
			const transmission = {
				stationId: stationId,
				startTime: startTime,
				endTime: null,
				audioPackets: [],
				totalDuration: 0,
				firstPacketTime: null,
				lastPacketTime: null,
				transmissionId: transmissionId,  // Use server's ID
				incomplete: true,
				timeoutId: null
			};
			
			activeTransmissions.set(stationId, transmission);
			addLogEntry(`üì° Transmission started: ${transmissionId}`, 'success');
			
			// Show temporary indicator
			showNotification(`üìª ${stationId} started transmitting`, 'info');
		}

		function endTransmissionFromServer(stationId, endTime, transmissionId) {
			const transmission = activeTransmissions.get(stationId);
			if (!transmission) {
				console.log(`‚ö†Ô∏è Tried to end transmission for ${stationId} but none active`);
				return;
			}
			
			// CRITICAL FIX: Update the transmission with server's final ID
			console.log(`üîÑ ID SYNC: Updating transmission ID from ${transmission.transmissionId} to ${transmissionId}`);
			transmission.transmissionId = transmissionId;
			transmission.endTime = endTime;
			transmission.incomplete = false;
			
			// Clear timeout
			if (transmission.timeoutId) {
				clearTimeout(transmission.timeoutId);
			}
			
			console.log(`üì° TRANSMISSION COMPLETE: ${transmission.transmissionId} - `
						+ `${transmission.audioPackets.length} packets, ${transmission.totalDuration}ms`);
			
			// Move to completed transmissions
			completedTransmissions.push(transmission);
			activeTransmissions.delete(stationId);
			
			// Cleanup old transmissions
			if (completedTransmissions.length > maxTransmissions) {
				completedTransmissions = completedTransmissions.slice(-maxTransmissions);
			}
			
			// Create UI bubble for the complete transmission
			if (transmission.audioPackets.length > 0) {
				createTransmissionUIBubble(transmission);
				const duration = (transmission.totalDuration / 1000).toFixed(1);
				addLogEntry(`üìª Transmission completed: ${stationId} (${transmission.audioPackets.length} packets, ${duration}s)`, 'success');
				showNotification(`üìª ${stationId} transmission complete (${duration}s)`, 'success');
			} else {
				console.log(`‚ö†Ô∏è No audio packets in transmission from ${stationId}`);
				addLogEntry(`‚ö†Ô∏è Empty transmission from ${stationId}`, 'warning');
			}
		}








		// Handle transmission audio data from server (not called!) AI!!!
		function handleTransmissionAudioData(audioData) {
			console.log('üéµ TRANSMISSION AUDIO: Received actual audio data');
			console.log('   Audio data keys:', Object.keys(audioData));
			console.log('   Sample rate:', audioData.sample_rate);
			console.log('   Channels:', audioData.channels);
			console.log('   Format:', audioData.audio_format);
			console.log('   Data length:', audioData.audio_data ? audioData.audio_data.length : 0, 'chars (base64)');
			
			// Ensure audio context is available
			if (!audioContext) {
				console.log('üéµ TRANSMISSION AUDIO: No audio context - initializing');
				if (!initializeWebAudio()) {
					console.error('üéµ TRANSMISSION AUDIO: Failed to initialize audio context');
					return;
				}
			}
			
			try {
				// Step 1: Decode base64 audio data to binary
				const base64Data = audioData.audio_data;
				if (!base64Data) {
					console.error('üéµ TRANSMISSION AUDIO: No audio data provided');
					return;
				}
				
				// Decode base64 to ArrayBuffer
				const binaryString = atob(base64Data);
				const bytes = new Uint8Array(binaryString.length);
				for (let i = 0; i < binaryString.length; i++) {
					bytes[i] = binaryString.charCodeAt(i);
				}
				
				console.log('üéµ TRANSMISSION AUDIO: Decoded', bytes.length, 'bytes of PCM data');
				
				// Step 2: Convert 16-bit signed PCM to Float32Array
				const sampleRate = audioData.sample_rate || 48000;
				const channels = audioData.channels || 1;
				const pcmSamples = bytes.length / 2; // 16-bit = 2 bytes per sample
				
				// Create Int16Array view of the data
				const pcmInt16 = new Int16Array(bytes.buffer);
				console.log('üéµ TRANSMISSION AUDIO: PCM samples:', pcmInt16.length);
				
				// Convert to Float32Array (Web Audio format)
				const floatSamples = new Float32Array(pcmInt16.length);
				for (let i = 0; i < pcmInt16.length; i++) {
					floatSamples[i] = pcmInt16[i] / 32768.0; // Convert 16-bit to float (-1.0 to 1.0)
				}
				
				console.log('üéµ TRANSMISSION AUDIO: Converted to float samples:', floatSamples.length);
				
				// Step 3: Create Web Audio buffer
				const audioBuffer = audioContext.createBuffer(channels, floatSamples.length, sampleRate);
				
				// Copy float data to audio buffer
				for (let channel = 0; channel < channels; channel++) {
					const channelData = audioBuffer.getChannelData(channel);
					if (channels === 1) {
						// Mono: copy all samples to this channel
						channelData.set(floatSamples);
					} else {
						// Stereo: interleaved samples (not implemented for this use case)
						console.warn('üéµ TRANSMISSION AUDIO: Stereo not implemented');
						channelData.set(floatSamples); // Fallback: copy mono to all channels
					}
				}
				
				console.log('üéµ TRANSMISSION AUDIO: Audio buffer created');
				console.log('   Duration:', audioBuffer.duration.toFixed(3), 'seconds');
				console.log('   Sample rate:', audioBuffer.sampleRate, 'Hz');
				console.log('   Channels:', audioBuffer.numberOfChannels);
				
				// Step 4: Create audio source and play
				const source = audioContext.createBufferSource();
				source.buffer = audioBuffer;
				
				// Connect to speakers
				source.connect(audioContext.destination);
				
				// Add some gain control to prevent clipping
				const gainNode = audioContext.createGain();
				gainNode.gain.value = 0.7; // Reduce volume slightly
				source.connect(gainNode);
				gainNode.connect(audioContext.destination);
				
				// Play the audio
				const startTime = audioContext.currentTime;
				source.start(startTime);
				
				console.log('üéµ TRANSMISSION AUDIO: ‚úÖ PLAYING NOW! Duration:', audioBuffer.duration.toFixed(3), 's');
				
				// Update UI to show playback status
				const transmissionId = audioData.transmission_id;
				if (transmissionId) {
					const button = document.querySelector(`[data-transmission-id="${transmissionId}"] .audio-play-btn`);
					if (button) {
						const originalText = button.textContent;
						button.textContent = 'üîä Playing...';
						button.disabled = true;
						
						// Re-enable button after playback
						setTimeout(() => {
							button.textContent = originalText;
							button.disabled = false;
						}, audioBuffer.duration * 1000 + 100);
					}
				}
				
				// Show success notification
				showNotification(`üîä Playing ${audioData.from_station} transmission (${audioBuffer.duration.toFixed(1)}s)`, 'success');
				
			} catch (error) {
				console.error('üéµ TRANSMISSION AUDIO: ‚ùå PLAYBACK ERROR:', error);
				console.error('Error details:', error.stack);
				showNotification(`‚ùå Audio playback failed: ${error.message}`, 'error');
				
				// Re-enable button on error
				const transmissionId = audioData.transmission_id;
				if (transmissionId) {
					const button = document.querySelector(`[data-transmission-id="${transmissionId}"] .audio-play-btn`);
					if (button) {
						button.textContent = '‚ñ∂Ô∏è Replay';
						button.disabled = false;
					}
				}
			}
		}














// NEW: Outgoing transmission management functions
function startNewOutgoingTransmission(stationId, startTime, transmissionId) {
    console.log(`üì§ OUTGOING START: ${transmissionId} from ${stationId}`);
    
    // End any previous incomplete outgoing transmission
    if (activeOutgoingTransmissions.has(stationId)) {
        console.log(`‚ö†Ô∏è Force-ending previous incomplete outgoing transmission from ${stationId}`);
        const oldTransmission = activeOutgoingTransmissions.get(stationId);
        endOutgoingTransmission(stationId, new Date().toISOString(), oldTransmission.transmissionId);
    }
    
    const transmission = {
        stationId: stationId,
        startTime: startTime,
        endTime: null,
        audioPackets: [],
        totalDuration: 0,
        firstPacketTime: null,
        lastPacketTime: null,
        transmissionId: transmissionId,
        incomplete: true,
        timeoutId: null,
        direction: 'outgoing'
    };
    
    activeOutgoingTransmissions.set(stationId, transmission);
    addLogEntry(`üì§ Outgoing transmission started: ${transmissionId}`, 'success');
    
    // Show temporary indicator
    showNotification(`üìª You started transmitting`, 'info');
}

function endOutgoingTransmission(stationId, endTime, transmissionId) {
    const transmission = activeOutgoingTransmissions.get(stationId);
    if (!transmission) {
        console.log(`‚ö†Ô∏è Tried to end outgoing transmission for ${stationId} but none active`);
        return;
    }
    
    // Update transmission with server's final ID
    console.log(`üîÑ OUTGOING ID SYNC: Updating transmission ID from ${transmission.transmissionId} to ${transmissionId}`);
    transmission.transmissionId = transmissionId;
    transmission.endTime = endTime;
    transmission.incomplete = false;
    
    // Clear timeout
    if (transmission.timeoutId) {
        clearTimeout(transmission.timeoutId);
    }
    
    console.log(`üì§ OUTGOING TRANSMISSION COMPLETE: ${transmission.transmissionId} - `
                + `${transmission.audioPackets.length} packets, ${transmission.totalDuration}ms`);
    
    // Move to completed outgoing transmissions
    completedOutgoingTransmissions.push(transmission);
    activeOutgoingTransmissions.delete(stationId);
    
    // Cleanup old outgoing transmissions
    if (completedOutgoingTransmissions.length > maxTransmissions) {
        completedOutgoingTransmissions = completedOutgoingTransmissions.slice(-maxTransmissions);
    }
    
    // Create UI bubble for the complete outgoing transmission
    if (transmission.audioPackets.length > 0) {
        createTransmissionUIBubble(transmission, 'outgoing');  // NEW: Pass direction
        const duration = (transmission.totalDuration / 1000).toFixed(1);
        addLogEntry(`üìª Outgoing transmission completed: ${stationId} (${transmission.audioPackets.length} packets, ${duration}s)`, 'success');
        showNotification(`üìª Your transmission complete (${duration}s)`, 'success');
    } else {
        console.log(`‚ö†Ô∏è No audio packets in outgoing transmission from ${stationId}`);
        addLogEntry(`‚ö†Ô∏è Empty outgoing transmission from ${stationId}`, 'warning');
    }
}

function handleOutgoingAudioPacket(audioData) {
    const stationId = audioData.from_station;
    
    console.log(`üì§ OUTGOING AUDIO: Audio packet from ${stationId}: ${audioData.duration_ms}ms`);
    
    // Get active outgoing transmission
    let transmission = activeOutgoingTransmissions.get(stationId);
    
    if (!transmission) {
        // No active outgoing transmission - this shouldn't happen but handle gracefully
        console.log(`üì§ ‚ö†Ô∏è Auto-starting outgoing transmission for ${stationId} (no transmission start received)`);
        startNewOutgoingTransmission(stationId, audioData.timestamp, `tx_out_${stationId}_${Date.now()}`);
        transmission = activeOutgoingTransmissions.get(stationId);
    }
    
    // Add packet to outgoing transmission
    transmission.audioPackets.push(audioData);
    transmission.totalDuration += audioData.duration_ms;
    transmission.lastPacketTime = audioData.timestamp;
    
    if (!transmission.firstPacketTime) {
        transmission.firstPacketTime = audioData.timestamp;
    }
    
    // Reset auto-timeout for this outgoing transmission
    resetOutgoingTransmissionTimeout(stationId);
    
    console.log(`üì§ Added packet to outgoing transmission ${transmission.transmissionId} (${transmission.audioPackets.length} packets, ${transmission.totalDuration}ms total)`);
}

function resetOutgoingTransmissionTimeout(stationId) {
    const transmission = activeOutgoingTransmissions.get(stationId);
    if (!transmission) return;
    
    // Clear existing timeout
    if (transmission.timeoutId) {
        clearTimeout(transmission.timeoutId);
    }
    
    // Set new timeout
    transmission.timeoutId = setTimeout(() => {
        console.log(`‚è∞ Auto-ending outgoing transmission from ${stationId} (timeout)`);
        endOutgoingTransmission(stationId, new Date().toISOString(), transmission.transmissionId);
    }, transmissionTimeoutMs);
}





















		// Handle audio playback data from server
		function handleAudioPlaybackData(audioData) {
			console.log('üéµ Audio playback data:', audioData);
			
			// Check if this is transmission playback or individual audio playback
			if (audioData.transmission_id) {
				console.log('üéµ TRANSMISSION PLAYBACK: Received transmission playback data');
				console.log(`   Transmission ID: ${audioData.transmission_id}`);
				console.log(`   Total segments: ${audioData.total_segments || 1}`);
				
				// Find the transmission UI element
				const transmissionElement = document.querySelector(`[data-transmission-id="${audioData.transmission_id}"]`);
				if (transmissionElement) {
					const playButton = transmissionElement.querySelector('.audio-play-btn');
					if (playButton) {
						playButton.textContent = 'üîä Playing Transmission...';
						playButton.disabled = true;
						
						// Re-enable after estimated duration
						setTimeout(() => {
							playButton.textContent = '‚ñ∂Ô∏è Replay';
							playButton.disabled = false;
						}, audioData.duration_ms || 2000);
					}
				}
				
				showNotification(`üéµ Playing transmission from ${audioData.from_station} (${audioData.total_segments} segments)`, 'info');
				
			} else {
				// Individual audio playback (existing logic)
				const audioElement = document.querySelector(`[data-audio-id="${audioData.audio_id}"]`);
				if (audioElement) {
					const playButton = audioElement.querySelector('.audio-play-btn');
					if (playButton) {
						playButton.textContent = '‚è∏Ô∏è Playing...';
						playButton.disabled = true;
						
						// Re-enable after estimated duration
						setTimeout(() => {
							playButton.textContent = '‚ñ∂Ô∏è Play Audio';
							playButton.disabled = false;
						}, audioData.duration_ms || 2000);
					}
				}
				
				showNotification(`Playing audio from ${audioData.from_station}`, 'info');
			}
			
			// Note: Actual audio data streaming would require additional implementation
			// For now, we'll show a visual indication that audio is "playing"
			addLogEntry(`Audio playback started: ${audioData.duration_ms}ms`, 'info');
		}

		// Handle audio stream data
		function handleAudioStreamData(streamData) {
			console.log('üîä Audio stream data:', streamData);
			
			if (streamData.audio_available && streamData.packets > 0) {
				addLogEntry(`Audio stream: ${streamData.packets} packets available`, 'info');
				
				// Request audio stream periodically if enabled
				if (document.getElementById('enable-audio-streaming')?.checked) {
					setTimeout(() => {
						sendWebSocketMessage('get_audio_stream');
					}, 100);
				}
			}
		}

		// Initialize Web Audio API
		function initializeWebAudio() {
			try {
				// Create audio context (user interaction required)
				audioContext = new (window.AudioContext || window.webkitAudioContext)();
				addLogEntry('Web Audio initialized', 'success');
				return true;
			} catch (error) {
				addLogEntry(`Web Audio initialization failed: ${error.message}`, 'error');
				return false;
			}
		}

		// Show audio permission request
		function showAudioPermissionRequest() {
			const existingRequest = document.getElementById('audio-permission-request');
			if (existingRequest) return;
			
			const permissionDiv = document.createElement('div');
			permissionDiv.id = 'audio-permission-request';
			permissionDiv.className = 'audio-permission-request';
			permissionDiv.innerHTML = `
				<div class="permission-content">
					<h3>üé§ Audio Reception Available</h3>
					<p>Click to enable audio playback for received voice messages</p>
					<button onclick="enableAudioReception()" class="btn btn-primary">
						Enable Audio
					</button>
					<button onclick="dismissAudioRequest()" class="btn">
						Not Now
					</button>
				</div>
			`;
			
			document.body.appendChild(permissionDiv);
		}

		// Enable audio reception
		function enableAudioReception() {
			if (initializeWebAudio()) {
				showNotification('Audio reception enabled', 'success');
				dismissAudioRequest();
				
				// Request any pending audio
				sendWebSocketMessage('get_audio_stream');
			} else {
				showNotification('Failed to enable audio - check browser permissions', 'error');
			}
		}

		// Dismiss audio permission request
		function dismissAudioRequest() {
			const request = document.getElementById('audio-permission-request');
			if (request) {
				request.remove();
			}
		}

		// Update reception statistics
		function updateReceptionStats(stats) {
			console.log('üìä Reception stats:', stats);
			
			// Update counters
			if (stats.receiver_stats) {
				const receiverStats = stats.receiver_stats;
				
				// Update existing stats or create new display
				updateStatDisplay('audio-packets-received', receiverStats.audio_packets || 0);
				updateStatDisplay('text-packets-received', receiverStats.text_packets || 0);
				updateStatDisplay('total-packets-received', receiverStats.total_packets || 0);
			}
			
			// Update audio message count
			updateStatDisplay('audio-messages-stored', stats.audio_messages_stored || 0);
		}

		// Update individual stat display
		function updateStatDisplay(statId, value) {
			const statElement = document.getElementById(statId);
			if (statElement) {
				statElement.textContent = value;
			}
		}

		// Update audio reception statistics
		function updateAudioReceptionStats(audioData) {
			// Update audio reception counter
			const audioCounter = document.getElementById('audio-received-count');
			if (audioCounter) {
				const current = parseInt(audioCounter.textContent) || 0;
				audioCounter.textContent = current + 1;
			}
			
			// Update last received audio info
			const lastAudioInfo = document.getElementById('last-audio-info');
			if (lastAudioInfo) {
				const time = new Date(audioData.timestamp).toLocaleTimeString();
				lastAudioInfo.textContent = `${audioData.from_station} at ${time}`;

				//lastAudioInfo.textContent = `${audioData.from_station} (${audioData.duration_ms}ms)`;
				}
		}

		// Enhanced config message handling
		function handleEnhancedConfigMessage(message) {
			console.log('üîç ENHANCED HANDLER DEBUG: Received message type:', message.type);
			console.log('üîç ENHANCED HANDLER DEBUG: Message data:', message.data);
			
			switch (message.type) {
				case 'current_config':
					console.log('üîç ENHANCED HANDLER DEBUG: Processing current_config');
					populateEnhancedConfigFromData(message.data);
					break;
					
				case 'config_loaded':
					console.log('üîç ENHANCED HANDLER DEBUG: Processing config_loaded');
					showNotification(message.data.message, 'success');
					updateConfigStatus(`Loaded: ${message.data.filename}`);
					loadCurrentConfig();
					break;
					
				case 'config_saved':
					console.log('üîç ENHANCED HANDLER DEBUG: Processing config_saved');
					showNotification(message.data.message, 'success');
					updateConfigStatus(`Saved: ${message.data.filename}`);
					break;
					
				case 'connection_test_with_form_result':
					console.log('üîç ENHANCED HANDLER DEBUG: Processing connection_test_with_form_result');
					hideOperationProgress();
					const formTestResult = message.data;
					
					console.log('üîç ENHANCED HANDLER DEBUG: Form validation valid:', formTestResult.form_validation?.valid);
					
					if (formTestResult.form_validation?.valid) {
						// now check for warnings, even if results were valid
						let warningText = '';
						if (formTestResult.form_validation?.field_errors) {
							const fieldErrors = formTestResult.form_validation.field_errors;
            
							Object.keys(fieldErrors).forEach(field => {
								warningText += `${fieldErrors[field]}; `;
							});
						}
            
						// Form is valid, show system test results combined with warnings

						let statusMessage = formTestResult.system_test.success ?
						'System test passed with form values' :
						`System test issues: ${formTestResult.system_test.message}`;


						if (warningText) {	
							statusMessage = `${statusMessage} | ‚ö†Ô∏è ${warningText}`;
						}

						updateConfigStatus(statusMessage, formTestResult.system_test.success ? 'success' : 'warning');
						console.log('üîç ENHANCED HANDLER DEBUG: System test success:', formTestResult.system_test.success);
					} else {
						// Form validation failed
						const errors = formTestResult.form_validation.errors.join(', ');
						updateConfigStatus(`‚ùå Cannot test - form errors: ${errors}`, 'error');
						console.log('üîç ENHANCED HANDLER DEBUG: Form validation failed:', errors);
					}
					break;
					
				default:
					console.log('üîç ENHANCED HANDLER DEBUG: Unknown message type:', message.type);
			}
		}

		function testConnection() {
			addLogEntry('Testing system with current form values...', 'info');
			showOperationProgress('Gathering form data for testing...');
			
			try {
				console.log('üîç DEBUG: Starting form data gathering...');
				
				const formConfig = gatherEnhancedConfigData();
				console.log('üîç DEBUG: Form config gathered:', formConfig);
				console.log('üîç DEBUG: Form config type:', typeof formConfig);
				console.log('üîç DEBUG: Form config keys:', Object.keys(formConfig || {}));
				
				// Check specific fields
				console.log('üîç DEBUG: Callsign field value:', document.getElementById('callsign')?.value);
				console.log('üîç DEBUG: Target IP field value:', document.getElementById('target-ip')?.value);
				
				sendWebSocketMessage('test_connection_with_form', {
					form_config: formConfig,
					validate_form: true
				});
				
			} catch (error) {
				console.error('‚ùå Error in testConnection:', error);
				updateConfigStatus(`‚ùå Error: ${error.message}`, 'error');
				hideOperationProgress();
			}
		}

		// Configuration management functions - check





// IMPROVED: Add Enter key support to configuration filename inputs
function setupConfigurationEnterKeySupport() {
    // Load Configuration - Enter key support
    const loadInput = document.getElementById('load-config-filename');
    loadInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            loadConfigFile();
        }
    });

    // Save Configuration - Enter key support
    const saveInput = document.getElementById('save-config-filename');
    saveInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            saveConfigFile();
        }
    });

    // Create Template Configuration - Enter key support
    const createInput = document.getElementById('create-config-filename');
    createInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            createConfigFileEnhanced(); // Keep existing function name
        }
    });
}

















		function populateEnhancedConfigFromData(config) {

			console.log("üîç DEBUG: populateEnhancedConfigFromData called");
			console.log("üîç DEBUG: config object:", config);
			console.log("üîç DEBUG: metadata:", config._metadata);

			currentConfig = config;
			
			// Update current file display
			if (config._metadata && config._metadata.config_file_path) {
				document.getElementById('current-config-file').textContent = config._metadata.config_file_path;
			} else {
				document.getElementById('current-config-file').textContent = 'Default configuration';
			}
			

			// Station settings
			if (config.callsign) {
				document.getElementById('callsign').value = config.callsign;
				currentStation = config.callsign;
				document.getElementById('current-station').textContent = currentStation;
			}
			
			// Network settings
			if (config.network) {
				if (config.network.target_ip) document.getElementById('target-ip').value = config.network.target_ip;
				if (config.network.target_port) document.getElementById('target-port').value = config.network.target_port;
				if (config.network.listen_port) document.getElementById('listen-port').value = config.network.listen_port;
			}
			
			
			// Target Device Type settings
			if (config.protocol) {
				if (config.protocol.target_type) document.getElementById('target-type').value = config.protocol.target_type;
				if (config.protocol.keepalive_interval) document.getElementById('keepalive-interval').value = config.protocol.keepalive_interval;
			}
			
			// GPIO settings
			if (config.gpio) {
				if (config.gpio.ptt_pin) document.getElementById('ptt-pin').value = config.gpio.ptt_pin;
				if (config.gpio.led_pin) document.getElementById('led-pin').value = config.gpio.led_pin;
			}
			
			// Debug settings
			if (config.debug) {
				if (config.debug.verbose !== undefined) document.getElementById('verbose-mode').checked = config.debug.verbose;
				if (config.debug.quiet !== undefined) document.getElementById('quiet-mode').checked = config.debug.quiet;
				if (config.debug.log_level) document.getElementById('log-level-config').value = config.debug.log_level;
			}
			
			updateConfigStatus('Configuration loaded successfully');
		}

		// Enhanced config data gathering
		function gatherEnhancedConfigData() {
			return {
				callsign: document.getElementById('callsign').value.trim(),
				network: {
					target_ip: document.getElementById('target-ip').value.trim(),
					target_port: parseInt(document.getElementById('target-port').value) || 57372,
					listen_port: parseInt(document.getElementById('listen-port').value) || 57372
				},
				protocol: {
					target_type: document.getElementById('target-type').value || 'computer',
					keepalive_interval: parseFloat(document.getElementById('keepalive-interval').value) || 2.0
				},
				gpio: {
					ptt_pin: parseInt(document.getElementById('ptt-pin').value) || 23,
					led_pin: parseInt(document.getElementById('led-pin').value) || 17,
					button_bounce_time: 0.02,  // Default
					led_brightness: 1.0        // Default
				},
				debug: {
					verbose: document.getElementById('verbose-mode').checked,
					quiet: document.getElementById('quiet-mode').checked,
					log_level: document.getElementById('log-level-config').value || 'INFO'
				}
			};
		}




		function createConfigFileEnhanced() {
		    const filename = document.getElementById('create-config-filename').value.trim() || 'opulent_voice.yaml';
    	
		    // REMOVED: Template type selection (always use 'full' now)
		    // const templateType = document.getElementById('create-config-template').value;
		    
		    const data = {
		        filename: filename,
		        template_type: 'full'  // Always create full templates with comments
		    };
	    
		    showOperationProgress('Creating template configuration file...');
		    addLogEntry(`Creating template configuration file: ${filename}`, 'info');
		    sendWebSocketMessage('create_config', data);
		}








		function loadConfigFile() {
			const filename = document.getElementById('load-config-filename').value.trim();
			const data = filename ? { filename } : {};
			
			showOperationProgress('Loading configuration...');
			addLogEntry(`Loading configuration${filename ? ` from ${filename}` : ' (auto-discovery)'}...`, 'info');
			sendWebSocketMessage('load_config', data);
		}

		function saveConfigFile() {
			const filename = document.getElementById('save-config-filename').value.trim();
			const data = filename ? { filename } : {};
			
			showOperationProgress('Saving configuration...');
			addLogEntry(`Saving configuration${filename ? ` to ${filename}` : ' (auto-location)'}...`, 'info');
			sendWebSocketMessage('save_config', data);
		}

		function resetToDefaults() {
			if (confirm('Reset all configuration to defaults? This will clear the current form.')) {
				// Reset form to default values
				document.getElementById('callsign').value = '';
				document.getElementById('target-ip').value = '192.168.2.152';
				document.getElementById('target-port').value = '57372';
				document.getElementById('listen-port').value = '57372';
				document.getElementById('sample-rate').value = '48000';
				document.getElementById('frame-duration').value = '40';
				document.getElementById('prefer-usb').checked = true;
				document.getElementById('target-type').value = 'computer';
				document.getElementById('keepalive-interval').value = '2.0';
				document.getElementById('ptt-pin').value = '23';
				document.getElementById('led-pin').value = '17';
				document.getElementById('verbose-mode').checked = false;
				document.getElementById('quiet-mode').checked = false;
				document.getElementById('log-level-config').value = 'INFO';
				
				updateConfigStatus('Configuration reset to defaults');
				addLogEntry('Configuration form reset to defaults', 'info');
			}
		}

		// Progress indication functions
		function showOperationProgress(message) {
			const progressEl = document.getElementById('config-operation-progress');
			const textEl = progressEl.querySelector('.progress-text');
			textEl.textContent = message;
			progressEl.style.display = 'flex';
		}

		function hideOperationProgress() {
			const progressEl = document.getElementById('config-operation-progress');
			progressEl.style.display = 'none';
		}

		// Update config status with better formatting
		function updateConfigStatus(message, type = 'info') {
			const statusEl = document.getElementById('config-status');
			const timestamp = new Date().toLocaleTimeString();
			
			statusEl.textContent = `[${timestamp}] ${message}`;
			
			// Add visual feedback based on type
			statusEl.className = `config-status-message status-${type}`;
			
			// Hide progress indicator
			hideOperationProgress();
			
			// Auto-clear after 10 seconds
			setTimeout(() => {
				if (statusEl.textContent.includes(timestamp)) {
					statusEl.textContent = 'Ready to manage configuration files and settings';
					statusEl.className = 'config-status-message';
				}
			}, 10000);
		}

		// Logging system
		function addLogEntry(message, level = 'info') {
			const logContainer = document.getElementById('system-log');
			const entry = document.createElement('div');
			entry.className = `log-entry ${level}`;
			
			const timestamp = new Date().toLocaleTimeString();
			entry.innerHTML = `<span style="color: var(--text-secondary);">[${timestamp}]</span> ${message}`;
			
			logContainer.appendChild(entry);
			logContainer.scrollTop = logContainer.scrollHeight;
			
			// Limit log entries (keep last 100)
			while (logContainer.children.length > 100) {
				logContainer.removeChild(logContainer.firstChild);
			}
			
			filterLogEntries();
		}

		function clearLog() {
			document.getElementById('system-log').innerHTML = '';
			addLogEntry('Log cleared', 'info');
		}

		function filterLogEntries() {
			const selectedLevel = document.getElementById('log-level').value;
			const entries = document.querySelectorAll('.log-entry');
			
			entries.forEach(entry => {
				const entryLevel = entry.className.split(' ')[1];
				let show = false;
				
				switch (selectedLevel) {
					case 'all':
						show = true;
						break;
					case 'info':
						show = ['info', 'success', 'warning', 'error'].includes(entryLevel);
						break;
					case 'warning':
						show = ['warning', 'error'].includes(entryLevel);
						break;
					case 'error':
						show = entryLevel === 'error';
						break;
				}
				
				entry.style.display = show ? 'block' : 'none';
			});
		}

		// Notification system
		function showNotification(message, type = 'info') {
			const notification = document.getElementById('notification');
			notification.textContent = message;
			notification.className = `notification ${type}`;
			
			setTimeout(() => notification.classList.add('show'), 100);
			
			setTimeout(() => {
				notification.classList.remove('show');
			}, 4000);
		}

		// Accessibility helpers
		function announceToScreenReader(message) {
			const announcer = document.getElementById('sr-announcements');
			announcer.textContent = message;
			
			setTimeout(() => {
				announcer.textContent = '';
			}, 1000);
		}

		// Uptime counter
		function updateUptime() {
			const elapsed = Date.now() - startTime;
			const minutes = Math.floor(elapsed / 60000);
			const seconds = Math.floor((elapsed % 60000) / 1000);
			
			document.getElementById('uptime').textContent = 
				`${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
		}

		// Initialize reception features when DOM is loaded
		function initializeReceptionFeatures() {
			// Add audio controls to the interface
			//addAudioControls();  //commented out because they don't do anything for us
			
			// Add reception statistics display
			addReceptionStatsDisplay();
			
			// Set up audio streaming if enabled
			setupAudioStreaming();
			
			addLogEntry('Reception features initialized', 'info');
		}




	
		function addAudioControls() {
			// Add audio control panel to the interface
			const chatPanel = document.getElementById('chat-panel');
			if (chatPanel) {
				//const audioControls = document.createElement('div');
				//audioControls.className = 'audio-controls-panel';
				//audioControls.innerHTML = `
				//	<div class="control-group">
				//		<input type="checkbox" id="auto-play-audio" checked>
				//		<label for="auto-play-audio">Auto-play received audio</label>
				//	</div>
				//	<div class="control-group">
				//		<input type="checkbox" id="enable-message-sounds" checked>
				//		<label for="enable-message-sounds">Message notification sounds</label>
				//	</div>
				//	<div class="control-group">
				//		<input type="checkbox" id="enable-audio-streaming">
				//		<label for="enable-audio-streaming">Real-time audio streaming</label>
				//	</div>
				//`;
				
				// Insert before chat container
				const chatContainer = chatPanel.querySelector('.chat-container');
				chatPanel.insertBefore(audioControls, chatContainer);
			}
		}

		function addReceptionStatsDisplay() {
			// Add reception stats to the status panel
			const statusPanel = document.querySelector('.panel:last-child .status-grid');
			if (statusPanel) {
				const receptionStats = document.createElement('div');
				receptionStats.className = 'stat-item';
				receptionStats.innerHTML = `
					<span class="stat-label">Audio Frames Received</span>
					<span id="audio-received-count" class="stat-value">0</span>
				`;
				statusPanel.appendChild(receptionStats);
				
				const lastAudioStat = document.createElement('div');
				lastAudioStat.className = 'stat-item';
				lastAudioStat.innerHTML = `
					<span class="stat-label">Last Audio From</span>
					<span id="last-audio-info" class="stat-value">None</span>
				`;
				statusPanel.appendChild(lastAudioStat);
			}
		}

		function setupAudioStreaming() {
			// Set up audio streaming checkbox handler
			const streamingCheckbox = document.getElementById('enable-audio-streaming');
			if (streamingCheckbox) {
				streamingCheckbox.addEventListener('change', function() {
					if (this.checked) {
						if (!audioContext && !initializeWebAudio()) {
							this.checked = false;
							showNotification('Cannot enable streaming - audio not available', 'error');
							return;
						}
						addLogEntry('Audio streaming enabled', 'info');
						sendWebSocketMessage('get_audio_stream');
					} else {
						addLogEntry('Audio streaming disabled', 'info');
					}
				});
			}
		}

		// Event listeners
		document.addEventListener('DOMContentLoaded', function() {
			initializeReceptionFeatures();
			
			// Message form handling
			const messageForm = document.getElementById('message-form');
			const messageInput = document.getElementById('message-input');
			
			messageForm.addEventListener('submit', function(e) {
				e.preventDefault();
				sendMessage();
			});

			messageInput.addEventListener('keydown', function(e) {
				if (e.key === 'Enter' && !e.shiftKey) {
					e.preventDefault();
					sendMessage();
				}
			});

			// Auto-resize textarea
			messageInput.addEventListener('input', function() {
				this.style.height = 'auto';
				this.style.height = Math.min(this.scrollHeight, 100) + 'px';
			});

			// PTT button handling
			const pttButton = document.getElementById('ptt-button');
			pttButton.addEventListener('click', function() {
				if (!ws || ws.readyState !== WebSocket.OPEN) {
					showNotification('Cannot use PTT: not connected', 'error');
					return;
				}
				togglePTT();
			});

			// Keyboard PTT (spacebar)
			document.addEventListener('keydown', function(e) {
				if (e.code === 'Space' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
					e.preventDefault();
					if (!pttActive && ws && ws.readyState === WebSocket.OPEN) {
						activatePTT();
					}
				}
			});

			document.addEventListener('keyup', function(e) {
				if (e.code === 'Space' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
					e.preventDefault();
					if (pttActive) {
						deactivatePTT();
					}
				}
			});

			// Log level filter
			document.getElementById('log-level').addEventListener('change', filterLogEntries);

			// Keyboard shortcuts
			document.addEventListener('keydown', function(e) {
				// Ctrl+1 for Chat tab
				if (e.ctrlKey && e.key === '1') {
					e.preventDefault();
					switchTab('chat');
				}
				
				// Ctrl+2 for Config tab
				if (e.ctrlKey && e.key === '2') {
					e.preventDefault();
					switchTab('config');
				}
				
				// Escape to release PTT
				if (e.key === 'Escape' && pttActive) {
					e.preventDefault();
					deactivatePTT();
				}
			});

			// Start uptime counter
			setInterval(updateUptime, 1000);

			// IMPROVED: Setup configuration Enter key support
			setupConfigurationEnterKeySupport();

			// Initialize connection
			addLogEntry('Starting Opulent Voice Web Interface', 'info');
			connectWebSocket();



		});

		// Handle page visibility for WebSocket reconnection
		document.addEventListener('visibilitychange', function() {
			if (!document.hidden && (!ws || ws.readyState !== WebSocket.OPEN)) {
				addLogEntry('Page became visible - checking connection', 'info');
				connectWebSocket();
			}
		});

		// Make functions globally available
		window.radioInterface = {
			connectWebSocket,
			sendWebSocketMessage,
			switchTab,
			sendMessage,
			togglePTT,
			applyConfig,
			saveConfig,
			showNotification,
			addLogEntry,
			attemptReconnect,
			initializeWebAudio,
			enableAudioReception,
			playCompleteTransmission,
			initializeReceptionFeatures
		};

		// Add status type styles
		const additionalStyles = `
		<style>
		.status-success { color: var(--success-color) !important; }
		.status-warning { color: var(--warning-color) !important; }
		.status-error { color: var(--error-color) !important; }
		.status-info { color: var(--text-secondary) !important; }
		</style>
		`;
		document.head.insertAdjacentHTML('beforeend', additionalStyles);

	</script>
</body>
</html>
			
